
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <meta name="author" content="培风">
      
      
        <link rel="canonical" href="https://isnthzy.github.io/src/Chisel%20%E4%B8%AD%E6%96%87%E6%95%99%E7%A8%8B/">
      
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.2, mkdocs-material-9.2.3">
    
    
      
        <title>Chisel 中文教程 - 培风的博客</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.0e669242.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.85d0ee34.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="blue" data-md-color-accent="blue">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#chisel-chisel-data-types" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="培风的博客" class="md-header__button md-logo" aria-label="培风的博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            培风的博客
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Chisel 中文教程
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/isnthzy/isnthzy.github.io/" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    isnthzy/isnthzy.github.io
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="培风的博客" class="md-nav__button md-logo" aria-label="培风的博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    培风的博客
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/isnthzy/isnthzy.github.io/" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    isnthzy/isnthzy.github.io
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    主页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%8F%90%E9%97%AE%E7%9A%84%E6%99%BA%E6%85%A7%E8%AF%BB%E5%90%8E%E6%84%9F/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    提问的智慧读后感
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    linux笔记
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            linux笔记
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../TMUX%E4%B8%8EVIM/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    TMUX与VIM
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../git%E7%9A%84%E7%94%A8%E6%B3%95/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    git用法
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../Linux%E4%BD%BF%E7%94%A8man%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Linux使用man中文手册
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF%E7%9A%84makefile%E7%B2%BE%E8%A7%A3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    一生一芯的makefile精解
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../Makefile%E5%AD%A6%E4%B9%A0/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Makefile学习随笔
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%BE%99%E8%8A%AF%E6%9D%AF%E4%B8%AA%E4%BA%BA%E8%B5%9B%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    龙芯杯个人赛编译教程
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../Verilog%E9%9A%8F%E7%AC%94/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Verilog笔记
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../NJU%20PA1-%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E6%89%8B%E5%86%8C/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    NJU PA1-如何阅读手册
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../ELF%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E8%AF%BB/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ELF文件怎么读
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../PA2.1%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4%E5%9C%A8NEMU%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    NJU PA2.1一条指令在NEMU中的执行过程
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E6%B7%B1%E8%A7%A3/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    表达式求值深解
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../__am_gpu_config%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E8%A1%8C%E4%BC%98%E5%85%88%E5%AD%98%E5%82%A8%E6%98%AF%E4%BB%80%E4%B9%88/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    __am_gpu_config的实现以及行优先存储是什么
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../Chisel%E7%9A%84scala%20maven%E6%BA%90/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chisel的scala maven源
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../compile_commands.json%E6%9B%B4%E5%85%88%E8%BF%9B%E7%9A%84%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    compile_commands.json随笔
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../difftest%E7%B3%BB%E7%BB%9F%E8%B8%A9%E5%9D%91%E8%A7%A3%E8%AF%BB/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    difftest系统踩坑解读
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../gtkwave%E9%85%8D%E7%BD%AE%E5%BF%83%E5%BE%97/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    gtkwave配置心得
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%9A%8F%E7%AC%94/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    异常处理随笔
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../pa3%E5%81%9A%E5%AE%8C%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    pa3做完的碎碎念
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#casting" class="md-nav__link">
    类型转换（Casting）
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#analogblackbox-type" class="md-nav__link">
    模拟/黑盒类型（Analog/BlackBox type）
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<div class="toc">
<ul>
<li><a href="#chisel-chisel-data-types">Chisel 数据类型（Chisel Data Types）</a><ul>
<li><a href="#casting">类型转换（Casting）</a></li>
<li><a href="#analogblackbox-type">模拟/黑盒类型（Analog/BlackBox type）</a></li>
</ul>
</li>
<li><a href="#bundles-and-vecs">Bundles and Vecs</a><ul>
<li><a href="#bundles-flipping-bundles">翻转 Bundles - Flipping Bundles</a></li>
<li><a href="#mixedvec">MixedVec</a></li>
</ul>
</li>
<li><a href="#combinational-circuits">组合电路（Combinational Circuits）</a><ul>
<li><a href="#wires">导线（Wires）</a></li>
</ul>
</li>
<li><a href="#opretors">操作符（Opretors）</a></li>
<li><a href="#width-inference">位宽推断（Width Inference）</a></li>
<li><a href="#functional-abstraction">函数抽象（Functional Abstraction）</a></li>
<li><a href="#ports">端口（Ports）</a><ul>
<li><a href="#inspecting-module-ports">检查模块端口（Inspecting Module ports）</a></li>
</ul>
</li>
<li><a href="#modules">模块（Modules）</a><ul>
<li><a href="#module-hierarchy">模块层次（Module Hierarchy）</a></li>
<li><a href="#rawmodule">RawModule</a></li>
</ul>
</li>
<li><a href="#sequential-circuits">时序电路（Sequential Circuits）</a></li>
<li><a href="#memories">存储（Memories）</a><ul>
<li><a href="#rom">ROM</a></li>
<li><a href="#read-write-memories">读写存储（Read-Write Memories）</a><ul>
<li><a href="#ram-syncreadmem">同步读 RAM SyncReadMem：同步读取，同步写入</a></li>
<li><a href="#read-portwrite-port">读端口/写端口（Read port/write port）</a></li>
<li><a href="#single-ported">单端口（Single-ported）</a></li>
<li><a href="#mem">Mem: 异步读取，同步写入</a></li>
</ul>
</li>
<li><a href="#masks">掩码（Masks）</a></li>
<li><a href="#memory-initialization">存储初始化（Memory Initialization）</a></li>
</ul>
</li>
<li><a href="#interfaces-connections">接口和连接（Interfaces &amp; Connections）</a><ul>
<li><a href="#ports-subclasses-nesting">端口：子类和网络（Ports: Subclasses &amp; Nesting）</a></li>
<li><a href="#bundle-vectors">Bundle Vectors</a></li>
<li><a href="#bulk-connections">批量连接（Bulk Connections）</a></li>
<li><a href="#monoconnect-algorithm">MonoConnect Algorithm</a></li>
<li><a href="#biconnect-algorithm">BiConnect Algorithm</a></li>
<li><a href="#the-standard-ready-valid-interface-readyvalidio-decoupled">The standard ready-valid interface (ReadyValidIO / Decoupled)</a></li>
</ul>
</li>
<li><a href="#blackboxes">BlackBoxes</a><ul>
<li><a href="#_1">参数化</a></li>
<li><a href="#blackboxes_1">提供实现的 BlackBoxes</a></li>
<li><a href="#verilog-blackboxes">Verilog 在资源文件中的 BlackBoxes</a></li>
<li><a href="#verilog-blackboxes_1">内联 Verilog 的 BlackBoxes</a></li>
<li><a href="#_2">引擎之下</a></li>
</ul>
</li>
<li><a href="#chisel-chiselenum">Chisel 枚举（ChiselEnum）</a><ul>
<li><a href="#_3">功能和示例</a></li>
<li><a href="#_4">类型转换</a></li>
<li><a href="#_5">测试</a></li>
<li><a href="#_6">解决问题</a></li>
<li><a href="#_7">其他资源</a></li>
</ul>
</li>
<li><a href="#dataview">DataView</a><ul>
<li><a href="#_8">介绍</a></li>
<li><a href="#axi4">一个使用示例（AXI4）</a></li>
<li><a href="#_9">其他示例</a></li>
<li><a href="#tuple">元组（Tuple）</a></li>
<li><a href="#dataview_1">完全的和部分的 DataView</a></li>
<li><a href="#_10">进阶细节</a><ul>
<li><a href="#type">Type 类</a></li>
<li><a href="#implicit">implicit 解析</a><ul>
<li><a href="#implicit_1">implicit 解析示例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#dataproduct">DataProduct</a></li>
</ul>
</li>
<li><a href="#function-module-creation">功能模块创建（Function Module Creation）</a></li>
<li><a href="#muxes-and-input-selection">多路复用器和输入选择（Muxes and Input Selection）</a><ul>
<li><a href="#mux">Mux</a></li>
<li><a href="#muxcase">MuxCase</a></li>
<li><a href="#muxlookup">MuxLookup</a></li>
<li><a href="#mux1h">Mux1H</a></li>
</ul>
</li>
<li><a href="#multiple-clock-domains">多时钟域（Multiple Clock Domains）</a></li>
<li><a href="#reset">复位（Reset）</a><ul>
<li><a href="#_11">复位推断</a></li>
<li><a href="#_12">隐式复位</a><ul>
<li><a href="#_13">设置隐式复位类型</a></li>
</ul>
</li>
<li><a href="#reset-agnostic-code">与复位无关的代码（Reset-Agnostic Code）</a></li>
<li><a href="#forcing-reset-type">强制复位类型（Forcing Reset Type）</a></li>
<li><a href="#last-connect-semantics">最后连接语义（Last-Connect Semantics）</a></li>
</ul>
</li>
<li><a href="#polymorphism-and-parameterization">多态与参数化（Polymorphism and Parameterization）</a><ul>
<li><a href="#_14">参数化函数</a></li>
<li><a href="#_15">参数化类</a></li>
<li><a href="#_16">基于模块的参数化</a></li>
</ul>
</li>
<li><a href="#chisel-printing-in-chisel">在 Chisel 中打印（Printing in Chisel）</a><ul>
<li><a href="#scala">Scala 风格</a><ul>
<li><a href="#_17">简单的格式化</a></li>
<li><a href="#_18">聚合数据类型</a></li>
<li><a href="#_19">自定义打印</a></li>
</ul>
</li>
<li><a href="#c">C 风格</a></li>
</ul>
</li>
<li><a href="#naming">命名（Naming）</a><ul>
<li><a href="#_20">编译插件</a><ul>
<li><a href="#_21">前缀</a></li>
<li><a href="#suggest-a-signals-name-or-the-instance-name-of-a-module">Suggest a Signal’s Name (or the instance name of a Module)</a></li>
<li><a href="#unnamed-signals-temporaries">“Unnamed signals” 的行为（又名 “Temporaries”）</a></li>
<li><a href="#_22">设置一个模块名称</a></li>
</ul>
</li>
<li><a href="#_23">映射命名</a></li>
<li><a href="#chiselname">@chiselName</a></li>
</ul>
</li>
<li><a href="#unconnected-wires">未连接的线（Unconnected Wires）</a><ul>
<li><a href="#api">API</a></li>
<li><a href="#_24">确定未连接的元素</a></li>
</ul>
</li>
<li><a href="#chisel-vs-scala">Chisel 类型 vs Scala 类型</a><ul>
<li><a href="#scala-vs-chisel-vs">Scala 类型 vs Chisel 类型 vs 硬件类型</a></li>
<li><a href="#chisel-vs-vs">Chisel 类型 vs 硬件类型 vs 字符</a></li>
<li><a href="#chisel-type-vs-hardware-specific-functions-and-errors">Chisel Type vs Hardware – Specific Functions and Errors</a></li>
</ul>
</li>
<li><a href="#connectable-operators">连接操作符（Connectable Operators）</a><ul>
<li><a href="#_25">术语</a></li>
<li><a href="#_26">概述</a></li>
<li><a href="#_27">对齐方式：翻转与对齐</a></li>
<li><a href="#_28">输入/输出</a></li>
<li><a href="#_29">使用完全对齐的成员连接组件</a><ul>
<li><a href="#_30">单向连接操作符（:=）</a></li>
</ul>
</li>
<li><a href="#_31">使用混合对齐的成员连接组件</a><ul>
<li><a href="#_32">双向连接操作符（:&lt;&gt;=）</a></li>
<li><a href="#_33">端口方向计算与连接方向计算</a></li>
<li><a href="#_34">对齐连接操作符 (:&lt;=)</a></li>
<li><a href="#_35">翻转连接操作符（:&gt;=）</a></li>
<li><a href="#_36">强制单向连接操作符（:#=）</a></li>
</ul>
</li>
<li><a href="#connectable">Connectable</a><ul>
<li><a href="#records">连接 Records</a></li>
<li><a href="#waived">waived 连接的默认</a></li>
<li><a href="#_37">与可选成员连接类型</a></li>
<li><a href="#_38">总是忽略由额外成员（部分连接操作符）造成的错误</a></li>
<li><a href="#_39">连接不同位宽的组件</a></li>
<li><a href="#_40">在可连接的任何操作符中排除任何成员</a></li>
<li><a href="#chisel">连接结构上不相等的 Chisel 类型的技术</a></li>
</ul>
</li>
<li><a href="#_41">使用冲突的名称连接同一超类的不同子类</a><ul>
<li><a href="#_42">通过忽略多余的成员将子类与超类连接</a></li>
<li><a href="#_43">连接不同的子类</a></li>
</ul>
</li>
<li><a href="#faq">FAQ</a></li>
</ul>
</li>
<li><a href="#decoders">译码器（Decoders）</a><ul>
<li><a href="#_44">基本译码器</a></li>
<li><a href="#decodertable">DecoderTable</a></li>
</ul>
</li>
<li><a href="#intrinsics">Intrinsics</a><ul>
<li><a href="#_45">参数化</a></li>
<li><a href="#example">Example</a></li>
</ul>
</li>
<li><a href="#annotations">Annotations</a></li>
<li><a href="#source-locators">源定位器（Source Locators）</a></li>
<li><a href="#_46">深入了解连接操作符</a><ul>
<li><a href="#_47">实验设置</a></li>
<li><a href="#1">概念 1：&lt;&gt; 是可交换的</a><ul>
<li><a href="#_48">结论：</a></li>
</ul>
</li>
<li><a href="#2-rhs-lhs-lhs">概念 2：:= 表示分配来自 RHS 的所有 LHS 信号，无论 LHS 上的方向如何。</a><ul>
<li><a href="#_49">结论：</a></li>
</ul>
</li>
<li><a href="#3-dontcare-wires">概念 3：总是使用 := 来把 DontCare 赋值给 Wires</a><ul>
<li><a href="#_50">结论：</a></li>
</ul>
</li>
<li><a href="#4-dontcare-ios">概念4：您可以使用 &lt;&gt; 或 := 将 DontCare 分配给有向的事物（IOs）</a><ul>
<li><a href="#_51">结论：</a></li>
</ul>
</li>
<li><a href="#5-io-io">概念5：&lt;&gt; 在至少一个已知流向（IO 或子模块的 IO）的事物之间起作用。</a><ul>
<li><a href="#_52">结论：</a></li>
</ul>
</li>
<li><a href="#6">概念6：&lt;&gt; 和 := 按字段名称连接信号。</a><ul>
<li><a href="#_53">结论：</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h1 id="chisel-chisel-data-types">Chisel 数据类型（Chisel Data Types）<a class="headerlink" href="#chisel-chisel-data-types" title="Permanent link">&para;</a></h1>
<p>Chisel 的数据类型用来指代保持在状态元素中或在导线上流动的值。虽然硬件设计是在操作二进制数的向量，但更抽象的表示它们的值使得规范更清晰，帮助工具生成优化更好的电路。在 Chisel 中，位的原始集合用 <code>bits</code> 类型来表示。有符号和无符号整数被认为是浮点数的子集，分别使用 <code>SInt</code> 和 <code>UInt</code> 来表示。有符号浮点数，包括整数用二进制补码形式表示。布尔值用 <code>Bool</code> 类型表示。请注意这些类型和 Scala 的内置格式，比如<code>Int</code>，<code>Boolean</code> 是不同的。</p>
<p>另外，Chisel 定义了 <code>Bundels</code> 来表示有命名字段的值的集合（类似于其他语言中的 <code>structs</code> ），并使用 <code>Vecs</code> 来表示可索引的值的集合。</p>
<p>Bundels 和 Vecs 将在下一节介绍。</p>
<p>常量和字符值使用传递给以下构造函数的 Scala 的整数和字符串来表示：</p>
<div class="highlight"><pre><span></span><code>1.U             // 从 Scala Int 类型中提取1位十进制数
&quot;ha&quot;.U          // 从字符串中提取 1 位十六进制数
&quot;o12&quot;.U         // 从字符串中提取 4 位八进制数
&quot;b1010&quot;.U       // 从字符串中提取 4 位二进制数

5.S             // 从 Scala Int 类型中提取 4 位有符号十进制数
-8.S            // 从 Scala Int 类型中提取负的 4 位有符号十进制数
5.U             // 从 Scala Int 类型中提取 3 位无符号十进制数

8.U(4.W)        // 4 位无符号十进制数，值为 8
-152.S(32.W)    // 32 位有符号十进制数，值为 -152

true.B 
false.B
</code></pre></div>
<p>为了可读性可以在长字符串中使用下划线作为分隔符，但在生成值时，下划线会被忽略，比如：</p>
<div class="highlight"><pre><span></span><code>&quot;h_dead_beef&quot;.U   // UInt 类型的 32 位值
</code></pre></div>
<p>默认情况下，Chisel 的编译器为了将每个常量设置为需要保持的最小为鼠，包括符号位和有符号类型。位宽可以直接指定，如下所示。（.W 被用来将 Scala Int 转换为一个 Chisel 宽度）</p>
<div class="highlight"><pre><span></span><code>&quot;ha&quot;.asUInt(8.W)      // UInt 类型的 8 位十六进制数
&quot;o12&quot;.asUInt(6.W)     // UInt 类型的 6 位八进制数
&quot;b1010&quot;.asUInt(12.W)  // UInt 类型的 12 位二进制数

5.asSInt(7.W)         // SInt 类型的 7 位有符号十进制数
5.asUInt(8.W)         // UInt 类型的 8 位无符号十进制数
</code></pre></div>
<p>对于 <code>UInt</code> 类型，所需位宽的值将会被 0 拓展；对于 <code>UInt</code> 类型，所需位宽的值将会被符号拓展。如果给出的位宽小于存储参数值的位宽，则会生成一个 Chisel error。</p>
<h2 id="casting">类型转换（Casting）<a class="headerlink" href="#casting" title="Permanent link">&para;</a></h2>
<p>我们能够在Chisel中进行类型转换：</p>
<div class="highlight"><pre><span></span><code>val sint = 3.S(4.W)             // 4 位 SInt

val uint = sint.asUInt          // 将 SInt 转换为 UInt
uint.asSInt                     // 将 UInt 转换为 SInt
</code></pre></div>
<p>注意：显式指定了宽度的 <code>asUInt</code>/<code>asSInt</code> 不能被用于 Chisel 数据类型的转换。不接受任何位宽参数，因为在连接对象时，Chisel 会根据需要自行填充和截断。</p>
<p>我们也能对时钟进行类型转换，但你应当小心这一点，应为时钟需要特别注意（尤其是在 ASIC 中）：</p>
<div class="highlight"><pre><span></span><code>val bool: Bool = false.B        // 恒定低电位导线
val clock = bool.asClock        // 恒定低电位时钟

clock.asUInt                    // 将时钟转换为 UInt （位宽为 1）
clock.asUInt.asBool             // 将时钟转换为 Bool (Chisel 3.2+)
clock.asUInt.toBool             // 将时钟转换为 Bool （只在Chisel 3.0 and 3.1 生效）
</code></pre></div>
<h2 id="analogblackbox-type">模拟/黑盒类型（Analog/BlackBox type）<a class="headerlink" href="#analogblackbox-type" title="Permanent link">&para;</a></h2>
<p>(试验类型, Chisel 3.1+)</p>
<p>Chisel 支持能够用来支持Chisel任意网络的 <code>Analog</code> 类型（等同于 Verilog 中的 <code>inout</code> 类型）。这包括模拟导线，三态/双向导线和电源网络（包含合适的注释）</p>
<p><code>Analog</code> 是一种无方向类型，所以可以用 <code>attach</code> 操作符将多个 <code>Analog</code> 网络连接在一起。也可以使用 <code>&lt;&gt;</code> 连接一次 <code>Analog</code> 网络，但连接多次是非法操作。</p>
<div class="highlight"><pre><span></span><code>val a = IO(Analog(1.W))
val b = IO(Analog(1.W))
val c = IO(Analog(1.W))

// 合法
attach(a, b)
attach(a, c)

// 合法
a &lt;&gt; b

// 非法 - 多次连接了 a
a &lt;&gt; b
a &lt;&gt; c
</code></pre></div>
<h1 id="bundles-and-vecs">Bundles and Vecs<a class="headerlink" href="#bundles-and-vecs" title="Permanent link">&para;</a></h1>
<p><code>Bundle</code> 和 <code>Vec</code> 是允许用户使用其他类型的聚合来拓展 Chisel 数据类型的类</p>
<p>Bundles 将一些可能不同类型的命名字段集合进一个连贯的单元中，很像 C 语言的结构体。用户通过将他们的类定义为 <code>Bundle</code> 的子类来定义自己的 Boundles。</p>
<div class="highlight"><pre><span></span><code>import chisel3._

class MyFloat extends Bundle {
  val sign        = Bool()
  val exponent    = UInt(8.W)
  val significand = UInt(23.W)
}

class ModuleWithFloatWire extends RawModule {
  val x  = Wire(new MyFloat)
  val xs = x.sign
}
</code></pre></div>
<p>你可以使用试验中的 Bundle Literals 功能来创建 literal Bundle。</p>
<p>Scala 约定使用 UpperCamleCase 作为命名规范，我们建议你在 Chisel 代码中保持这一规范。</p>
<p>Vecs 创建元素的可索引的向量，结构如下所示</p>
<div class="highlight"><pre><span></span><code>class ModuleWithVec extends RawModule {
  // 5 个 23 位有符号数的向量
  val myVec = Wire(Vec(5, SInt(23.W)))

  // 连接至其中一个元素
  val reg3 = myVec(3)
}
</code></pre></div>
<p>（注意我们指定了 <code>Vec</code> 元素的个数，类型，还指定了 SInt 的位宽）</p>
<p>这些基类(<code>SInt</code>, <code>UInt</code>, 和 <code>Bool</code>)还有聚合类(<code>Bundle</code> 和 <code>Vec</code>)都继承自一个公共的超类，<code>Data</code>。在硬件设计中，所有最终从 <code>Data</code> 继承的对象都能表示为位向量。</p>
<p>Bundles 和 Vecs 可以任意连接来构成复杂的数据结构：</p>
<div class="highlight"><pre><span></span><code>class BigBundle extends Bundle {
  // 5 个 23 位有符号数的向量
  val myVec = Vec(5, SInt(23.W))
  val flag = Bool()
  // 本节开头定义的 Bundle
  val f = new MyFloat
}
</code></pre></div>
<p>注意 Chisel 的基类和聚类在创建实例时不需要使用 <code>new</code>，但新的用户数据类型需要。可以定义 Scala <code>apply</code> 构造函数使用户数据类型也不需要使用 <code>new</code>，就像<a href="https://light-liuyi.top:2001/2023/06/12/Chisel-doc-translate/">函数构造 - Function Constructor</a> 中讲述的</p>
<h2 id="bundles-flipping-bundles">翻转 Bundles - Flipping Bundles<a class="headerlink" href="#bundles-flipping-bundles" title="Permanent link">&para;</a></h2>
<p><code>Flipped()</code> 函数递归的翻转 Bundle/Record 中的所有元素。这在创建一个互相连接的双向接口时非常有用（比如 <code>Decoupled</code>）。请看下面的示例：</p>
<div class="highlight"><pre><span></span><code>class ABBundle extends Bundle {
  val a = Input(Bool())
  val b = Output(Bool())
}

class MyFlippedModule extends RawMoudule {
  val normalBundle = IO(new ABBbundle)
  normakBundle.b := normalBundle.a

  val flippedBundle = IO(Flipped(new ABBundle))
  flippedBundle.a := flippedBundle.b
}
</code></pre></div>
<p>这会生成下面的 Verilog：</p>
<div class="highlight"><pre><span></span><code>// Generated by CIRCT firtool-1.43.0
module MyFlippedModule( // &lt;stdin&gt;:3:10
  input  normalBundle_a,    // bundles-and-vecs.md:60:24
         flippedBundle_b,   // bundles-and-vecs.md:65:25
  output normalBundle_b,    // bundles-and-vecs.md:60:24
         flippedBundle_a    // bundles-and-vecs.md:65:25
);

  assign normalBundle_b = normalBundle_a;   // &lt;stdin&gt;:3:10
  assign flippedBundle_a = flippedBundle_b; // &lt;stdin&gt;:3:10
endmodule
</code></pre></div>
<h2 id="mixedvec">MixedVec<a class="headerlink" href="#mixedvec" title="Permanent link">&para;</a></h2>
<p>(Chisel 3.2+)</p>
<p><code>Vec</code> 的所有元素必须有相同的参数化，如果我们想要创建一个元素有相同类型但不同参数化的 <code>Vec</code>，我们可以使用 MixedVec</p>
<div class="highlight"><pre><span></span><code>import chisel3.util.MixedVec

class ModuleMixedVec extends Module {
  val io = IO(new Bundle {
    val x = Input(UInt(3.W))
    val y = Input(UInt(10.W))
    val vec = Output(MixedVec(UInt(3.W), UInt(10.W)))
  })

  io.vec(0) := io.x
  io.vec(1) := io.y
}
</code></pre></div>
<p>我们还可以通过编程来在 MixedVec 里创建类型：</p>
<div class="highlight"><pre><span></span><code>class ModuleProgrammaticMixedVec(x: Int, y: Int) extends Module {
  val io = IO(new Bundle{
    val vec = Input(MixedVec((x to y) map {i =&gt; UInt(i.W)}))
    // ...
  })
  // ...
}
</code></pre></div>
<h1 id="combinational-circuits">组合电路（Combinational Circuits）<a class="headerlink" href="#combinational-circuits" title="Permanent link">&para;</a></h1>
<p>电路在 Chisel 中以节点图的形式保存。每个节点是一个 0 输入或多输入，驱动一个输出的硬件操作符。之前介绍的字符值是一种退化的节点，他没有输入并且驱动一个常量输出。创建节点并将其连接在一起的方法是使用文本表达式。比如，我们可以用下面这个例子表达一个简单的组合逻辑电路：</p>
<div class="highlight"><pre><span></span><code>(a &amp; b) | (~c &amp; d)
</code></pre></div>
<p>这个格式看起来很熟悉，用 <code>&amp;</code> 和 <code>|</code> 分别表示按位与和按位或，<code>~</code> 表示按位取反。 <code>a</code> 到 <code>d</code> 表示某种线宽（未指定）的命名导线。</p>
<p>任何简单表达式都可以转换成一个电路树(circuit tree)，导线作为树叶，运算符作为内部节点。表达式的电路最终的输出从树根部的操作符得出，在这个例子中，是按位或(<code>|</code>)。</p>
<p>简单表达式可以建立一个树状电路，但构建任意一个有向无环图(directed acyclic graphs, DAGs)电路，我们需要描述扇出（fan-out）。在 Chisel 中，我们通过命名一个包含子表达式的导线来实现，之后我们可以多次调用这个子表达式。我们在 Chisel 中声明一个变量来命名一个导线。例如，对于选择表达式，在下面的多路选择器描述中，什么是被是用了两次的：</p>
<div class="highlight"><pre><span></span><code>val sel = a | b
val out = (sel &amp; in1) | (~sel &amp; in0)
</code></pre></div>
<p><code>val</code> 是 Scala 的关键词，用来声明值不能被改变的变量。在这里用它命名 Chisel 导线，<code>sel</code>，保持第一个按位或操作符的输出，这样这个输出就可以在第二个表达式中被多次使用。</p>
<h2 id="wires">导线（Wires）<a class="headerlink" href="#wires" title="Permanent link">&para;</a></h2>
<p>Chisel 同样支持将导线作为硬件节点，给其赋值或连接其他节点
Chisel also supports wires as hardware nodes to which one can assign values or connect other nodes.</p>
<div class="highlight"><pre><span></span><code>val myNode = Wire(UInt(8.W))
when (isReady) {
  myNode := 255.U
} .otherwise {
  myNode := 0.U
}

val myNode = Wire(UInt(8.W))
when (input &gt; 128.U) {
  myNode := 255.U
} .elsewhen (input &gt; 64.U) {
  myNode := 1.U
} .otherwise {
  myNode := 0.U
}
</code></pre></div>
<p>注意导线的最后一次连接才生效。例如，下面两个 Chisel 电路是等价的：</p>
<div class="highlight"><pre><span></span><code>val myNode = Wire(UInt(8.W))
myNode := 10.U
myNode := 0.U

val myNode = Wire(UInt(8.W))
myNode := 0.U
</code></pre></div>
<h1 id="opretors">操作符（Opretors）<a class="headerlink" href="#opretors" title="Permanent link">&para;</a></h1>
<p>Chisel 定义了一个硬件操作符集合</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>位操作符</strong></td>
<td><strong>有效类型</strong>: SInt, UInt, Bool</td>
</tr>
<tr>
<td><code>val hiBits = x &amp; "h_ffff_0000".U</code></td>
<td>按位与</td>
</tr>
<tr>
<td><code>val invertedX = ~x</code></td>
<td>按位取反</td>
</tr>
<tr>
<td><code>val flagsOut = flagsIn | overflow</code></td>
<td>按位或</td>
</tr>
<tr>
<td><code>val flagsOut = flagsIn ^ toggle</code></td>
<td>按位异或</td>
</tr>
<tr>
<td><strong>位规约操作</strong></td>
<td><strong>有效类型</strong>: SInt, UInt <strong>返回类型</strong>: Bool</td>
</tr>
<tr>
<td><code>val allSet = x.andR</code></td>
<td>x 的每一位相与</td>
</tr>
<tr>
<td><code>val anySet = x.orR</code></td>
<td>x 的每一位相或</td>
</tr>
<tr>
<td><code>val parity = x.xorR</code></td>
<td>x 的每一位相异或</td>
</tr>
<tr>
<td><strong>相等判断</strong></td>
<td><strong>有效类型</strong>: SInt, UInt, Bool <strong>返回类型</strong>: Bool</td>
</tr>
<tr>
<td><code>val equ = x === y</code></td>
<td>相等</td>
</tr>
<tr>
<td><code>val neq = x =/= y</code></td>
<td>不相等</td>
</tr>
<tr>
<td><strong>移位</strong></td>
<td><strong>有效类型</strong>: SInt, UInt</td>
</tr>
<tr>
<td><code>val twoToTheX = 1.S &lt;&lt; x</code></td>
<td>逻辑左移</td>
</tr>
<tr>
<td><code>val hiBits = x &gt;&gt; 16.U</code></td>
<td>右移（UInt 时逻辑移位，SInt 时算术移位）</td>
</tr>
<tr>
<td><strong>位域操作</strong></td>
<td><strong>有效类型</strong>: SInt, UInt, Bool</td>
</tr>
<tr>
<td><code>val xLSB = x(0)</code></td>
<td>提取一位, 低位索引为 0</td>
</tr>
<tr>
<td><code>val xTopNibble = x(15, 12)</code></td>
<td>从结束位到开始位提取位字段</td>
</tr>
<tr>
<td><code>val usDebt = Fill(3, "hA".U)</code></td>
<td>多次复制一个位字符串</td>
</tr>
<tr>
<td><code>val float = Cat(sign, exponent, mantissa)</code></td>
<td>拼接位字段，第一个参数在左边</td>
</tr>
<tr>
<td><strong>逻辑操作符</strong></td>
<td><strong>有效类型</strong>: Bool</td>
</tr>
<tr>
<td><code>val sleep = !busy</code></td>
<td>逻辑非</td>
</tr>
<tr>
<td><code>val hit = tagMatch &amp;&amp; valid</code></td>
<td>逻辑与</td>
</tr>
<tr>
<td>`val stall = src1busy</td>
<td></td>
</tr>
<tr>
<td><code>val out = Mux(sel, inTrue, inFalse)</code></td>
<td>sel 为布尔变量的两输入选择器</td>
</tr>
<tr>
<td><strong>算术操作符</strong></td>
<td><strong>有效类型</strong>: SInt and UInt，<strong>对数字有效</strong></td>
</tr>
<tr>
<td><code>val sum = a + b or val sum = a +% b</code></td>
<td>加法（无宽度扩展）</td>
</tr>
<tr>
<td><code>val sum = a +&amp; b</code></td>
<td>加法（有宽度扩展）</td>
</tr>
<tr>
<td><code>val diff = a - b or val diff = a -% b</code></td>
<td>减法（无宽度扩展）</td>
</tr>
<tr>
<td><code>val diff = a -&amp; b</code></td>
<td>加法（有宽度扩展）</td>
</tr>
<tr>
<td><code>val prod = a * b</code></td>
<td>乘法</td>
</tr>
<tr>
<td><code>val div = a / b</code></td>
<td>除法</td>
</tr>
<tr>
<td><code>val mod = a % b</code></td>
<td>取模</td>
</tr>
<tr>
<td>算术比较</td>
<td><strong>有效类型</strong>: SInt and UInt，<strong>对数字有效</strong></td>
</tr>
<tr>
<td><code>val gt = a &gt; b</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>val gte = a &gt;= b</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>val lt = a &lt; b</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>val lte = a &lt;= b</code></td>
<td>小于等于</td>
</tr>
</tbody>
</table>
<p>Scala 语言约束了我们对于操作符名称的选择。我们不得不使用三等号 <code>===</code> 表示相等，用 <code>=\=</code> 表示不相等来保证原生的 Scala 相等操作符可以使用</p>
<p>Chisel 操作符的优先级没有定义为 Chisel 语言的一部分。实际上，他是由电路的评估等级决定的，天然遵循 Scala 操作符的优先级。如果对优先级存在怀疑，请使用括号。</p>
<p>Chisel/Scala 操作符的优先级与 Java 和 C 的优先级相似但不相同。Verilog 和 C 有相同的优先级，但 VHDL 没有。Verilog 的逻辑运算符有更高的优先级，但 VHDL 的那些操作符有相同的优先级，由左到右进行运算。</p>
<h1 id="width-inference">位宽推断（Width Inference）<a class="headerlink" href="#width-inference" title="Permanent link">&para;</a></h1>
<p>Chisel 提供了位宽推断来减少设计工作量。鼓励用户手动指定端口和寄存器的位宽以避免任何意外情况。但在其他时候，FIRRTL 编译器会推断出为指定的位宽</p>
<p>对于未指定位宽的电路组件，FIRRTL 编译器会推断出能够保持其合法传入连接的最小宽度。这里的含义是，在 Chisel 的赋值语句中，推理是从右向左进行的，即从左手边到右手边。如果一个组件没有传入链接，又未指定宽度，会抛出一个错误指出无法推断连接。</p>
<p>对于模块的未指定位宽的输入端口，推断的位宽是保证模块所有实例的传入连接合法的最小宽度。地型多路转换器(ground-typed multiplexor)表达式的宽度是其两个相应输入宽度中的最大值。对于复用聚合类型表达式（multiplexing aggregate-typed expressions），每个叶元素的结果宽度是其对应的两个输入叶元素的子元素宽度的最大值。条件有效表达式的宽度是其输入表达式的宽度。</p>
<p>下表定义了硬件操作符的输出宽度：</p>
<table>
<thead>
<tr>
<th>operation</th>
<th>bit width</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>z = x + y or z = x +% y</code></td>
<td><code>w(z) = max(w(x), w(y))</code></td>
</tr>
<tr>
<td><code>z = x +&amp; y</code></td>
<td><code>w(z) = max(w(x), w(y)) + 1</code></td>
</tr>
<tr>
<td><code>z = x - y or z = x -% y</code></td>
<td><code>w(z) = max(w(x), w(y))</code></td>
</tr>
<tr>
<td><code>z = x -&amp; y</code></td>
<td><code>w(z) = max(w(x), w(y)) + 1</code></td>
</tr>
<tr>
<td><code>z = x &amp; y</code></td>
<td><code>w(z) = max(w(x), w(y))</code></td>
</tr>
<tr>
<td><code>z = Mux(c, x, y)</code></td>
<td><code>w(z) = max(w(x), w(y))</code></td>
</tr>
<tr>
<td><code>z = w * y</code></td>
<td><code>w(z) = w(x) + w(y)</code></td>
</tr>
<tr>
<td><code>z = x &lt;&lt; n</code></td>
<td><code>w(z) = w(x) + maxNum(n)</code></td>
</tr>
<tr>
<td><code>z = x &gt;&gt; n</code></td>
<td><code>w(z) = w(x) - minNum(n)</code></td>
</tr>
<tr>
<td><code>z = Cat(x, y)</code></td>
<td><code>w(z) = w(x) + w(y)</code></td>
</tr>
<tr>
<td><code>z = Fill(n, x)</code></td>
<td><code>w(z) = w(x) * maxNum(n)</code></td>
</tr>
</tbody>
</table>
<p><code>w(z)</code> 是导线 z 的线宽，<code>&amp;</code> 规则适用于所有位逻辑操作符</p>
<p>给定一个以未指定宽度元素（最常见的是顶级输入）开头的连接路径，那么编译器将抛出一个异常，指示某个宽度不可更改。</p>
<p>一个常见的 “gotcha” 来自于用运算符 <code>+</code> 和 <code>-</code> 截断加法和减法。希望结果保持加法或减法的完全扩展精度的用户应该使用扩展运算符 <code>+&amp;</code> 和 <code>-&amp;</code>。</p>
<p>默认的截断操作来源于 Chisel 作为一个微处理器设计语言的历史。</p>
<h1 id="functional-abstraction">函数抽象（Functional Abstraction）<a class="headerlink" href="#functional-abstraction" title="Permanent link">&para;</a></h1>
<p>我们可以定义一个函数来表达重复的逻辑片段，这样我们可以在之后的设计中多次重用。例如，我们可以将我们之前用到的简单组合逻辑块包装为下面的格式</p>
<div class="highlight"><pre><span></span><code>def clb(a: UInt, b: UInt, c: UInt, d: UInt): UInt =
  (a &amp; b) | (~c &amp; d)
</code></pre></div>
<p>在这里 <code>clb</code> 是一个使用 <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> 作为参数并返回一个布尔电路的值的函数。关键字 <code>def</code> 是 Scala 的一部分，引入了一个函数定义，每个参数后紧跟一个冒号，然后是参数类型，函数的返回值类型在参数列表后的冒号后面。等号 <code>=</code> 分割了函数的参数列表和函数定义。</p>
<p>我们可以在之后的其他电路中这样使用这个函数：<code>val out = clb(a, b, c, d)</code></p>
<h1 id="ports">端口（Ports）<a class="headerlink" href="#ports" title="Permanent link">&para;</a></h1>
<p>端口是用来连接硬件组件的接口。端口只是指为其成员指定了方向的 <code>Data</code> 对象。</p>
<p>Chisel 提供了端口构建函数使得可以在构建对象时为其添加方向（输入或输出）。基类端口构造函数将端口的类型封装在 <code>Input</code> 或者 <code>Output</code> 中。</p>
<p>一个端口声明的示例如下所示：</p>
<div class="highlight"><pre><span></span><code>class Decoupled extends Bundle {
  val reagy = Output(Bool())
  val data = Input(UInt(32.W))
  val valid = Input(Bool())
}
</code></pre></div>
<p>在定义了 <code>Decoupled</code> 之后, 它变成了一个新的类型，可以根据需要作为模块的结构或者作为导线的集合。</p>
<p>通过将方向装入对象声明，Chisel 能够提供强大的布线结构，后面将会进行描述。</p>
<h2 id="inspecting-module-ports">检查模块端口（Inspecting Module ports）<a class="headerlink" href="#inspecting-module-ports" title="Permanent link">&para;</a></h2>
<p>(Chisel 3.2+)</p>
<p>chisel 3.2 提出了 <code>DataMirror.modulePorts</code>，可以用来检查任何 Chisel 模块的 IO（这包括 <code>import chisel3._</code> 和 <code>import chisel._</code>，以及每个模块中的黑盒）。这是使用这个 API 的示例：</p>
<div class="highlight"><pre><span></span><code>import chisel3.reflect.DataMirror
import chisel3.stage.ChiselGeneratorAnnotation
import circt.stage.ChiselStage

class Adder extends Module {
  val a = IO(Input(UInt(8.W)))
  val b = IO(Input(UInt(8.W)))
  val c = IO(Output(UInt(8.W)))

  c := a +&amp; b
}

class Test extends Module {
  val adder = Module(new Adder)
  // for debug only
  adder.a := DontCare
  adder.b := DontCare

  // 检查 adder 的端口
  // 在下面查看结果
  DataMirror.modulePorts(adder).foreach { case (name, port) =&gt; {
    println(s&quot;Found port $name: $port&quot;)
  }}
}

ChiselStage.emitSystemVerilog(new Test)

// Found port clock: Adder.clock: IO[Clock]
// Found port reset: Adder.reset: IO[Reset]
// Found port a: Adder.a: IO[UInt&lt;8&gt;]
// Found port b: Adder.b: IO[UInt&lt;8&gt;]
// Found port c: Adder.c: IO[UInt&lt;8&gt;]
// res0: String = &quot;&quot;&quot;// Generated by CIRCT firtool-1.43.0
// module Test( // &lt;stdin&gt;:13:10
//   input clock,   // &lt;stdin&gt;:14:11
//         reset    // &lt;stdin&gt;:15:11
// );
// 
// endmodule
// 
// &quot;&quot;&quot;
</code></pre></div>
<h1 id="modules">模块（Modules）<a class="headerlink" href="#modules" title="Permanent link">&para;</a></h1>
<p>Chisel 模块在定义生成电路的层级结构上和 Verilog 非常相似。</p>
<p>分层模块命名空间可在下游工具中访问，以帮助调试和物理布局。用户定义的模块定义为一个类，该类有以下特征：</p>
<ul>
<li>继承自 <code>Module</code>，</li>
<li>包含至少一个封装在模块的的 <code>IO()</code> 方法中的接口（传统上存储在名为 <code>io</code> 的端口字段中），以及</li>
<li>在其构造函数中将子电路连接在一起
  像这个示例一样定义你的 2 输入数据选择器模块：</li>
</ul>
<div class="highlight"><pre><span></span><code>import chisel3._

class Mux2IO extends Bundle {
  val sel = Input(UInt(1.W))
  val in0 = Input(UInt(1.W))
  val in1 = Input(UInt(1.W))
  val out = Output(UInt(1.W))
}

class Mux2 extends Module {
  val io = IO(new Mux2IO)

  io.out := (io.sel &amp; in1) | (~io.sel &amp; io.in0)
}
</code></pre></div>
<p>模块的接口是一个 <code>Bundle</code> 形式的端口集合，通过一个 <code>io</code> 字段定义。对于 <code>Mux2</code>，<code>io</code> 被定义为具有四个字段的集合，每个选择器端口一个字段。</p>
<p>定义体中用到的赋值操作符 <code>:=</code> 是 Chisel 中的特殊操作符，可以将左边的输入与右边的输出相连接。</p>
<h2 id="module-hierarchy">模块层次（Module Hierarchy）<a class="headerlink" href="#module-hierarchy" title="Permanent link">&para;</a></h2>
<p>我们现在可以创建电路的层级结构，即通过小的模块来构建大的模块。例如，我们可以将三个 2 输入数据选择器连接在一起，用 <code>Mux2</code> 模块构成 4 输入数据选择器：</p>
<div class="highlight"><pre><span></span><code>class Mux4IO extends Bundle {
  val in0 = Input(UInt(1.W))
  val in1 = Input(UInt(1.W))
  val in2 = Input(UInt(1.W))
  val in3 = Input(UInt(1.W))
  val sel = Input(UInt(2.W))
  val out = Output(UInt(1.W))
}

class Mux4 extends Module {
  val io = IO(new Mux4IO)

  val m0 = Module(new Mux2)
  m0.io.sel := io.sel(0)
  m0.io.in0 := io.in0
  m0.io.in1 := io.in1

  val m1 = Module(new Mux2)
  m1.io.sel := io.sel(0)
  m1.io.in0 := io.in2
  m1.io.in1 := io.in3

  val m2 = Module(new Mux2)
  m2.io.sel := io.sel(1)
  m2.io.in0 := m0.io.out
  m2.io.in1 := m1.io.out

  io.out := m2.io.out

}
</code></pre></div>
<p>我们又一次定义了像 <code>io</code> 这样的模块接口并连接了输入和输出。在这个例子中，我们创建了三个 <code>Mux2</code> 子模块，用 <code>Module</code> 的构造函数和 Scala 的关键字 <code>new</code> 创造了一个新的对象。之后我们将他们互相连接起来，并连接到 <code>Mux4</code> 接口的端口上。</p>
<p>注意：Chisel 模块有一个隐式的时钟（命名为 <code>clock</code>）和一个隐式的复位（命名为 <code>reset</code>）。Chisel 提供了 <code>RawModule</code> 来创建没有隐式时钟和复位的模块。</p>
<h2 id="rawmodule"><code>RawModule</code><a class="headerlink" href="#rawmodule" title="Permanent link">&para;</a></h2>
<p><code>RawModule</code> 是一个**不提供隐式时钟和复位**的模块。这在希望将 Chisel 模块与指定命名的时钟和复位连接时可能会很有用。</p>
<p>我们可以用它来代替 <em>Module</em> 的使用：</p>
<div class="highlight"><pre><span></span><code>import chisel3.{RawModule, withClockAndReset}

class Foo extends Module {
  val io = (new Bundle {
    val a = Input(Bool())
    val b = Output(Bool())
  })

  io.b := !io.a
}

class FooWrapper extends RawModule {
  val a_i = IO(Input(Bool()))
  val b_o = IO(Output(Bool()))
  val clk = IO(Input(Clock()))
  val rstn = IO(Input(Bool()))

  val foo = withClockAndReset{clk, !rstn}{ Module (new Foo) }

  foo.io.a := a_i
  b_o := foo.io.b
}
</code></pre></div>
<p>在上面的例子中，<code>RawModule</code>被用来改变 <code>SlaveSpi</code> 复位信号的极性。事实上，Chisel 模块中默认的复位时高电位激活，用 <code>withClockAndReset(clock, !rstn)</code> 我们能够在整个设计中使用低电位触发的复位。</p>
<p>时钟按照原样接线，但如果需要，<code>RawModule</code> 可以和 <code>BlackBox</code> 混合使用，比如连接差分时钟输入。
The clock is just wired as is, but if needed, RawModule can be used in conjunction with BlackBox to connect a differential clock input for example.</p>
<h1 id="sequential-circuits">时序电路（Sequential Circuits）<a class="headerlink" href="#sequential-circuits" title="Permanent link">&para;</a></h1>
<p>Chisel 支持的最简单形式的状态元素是一个上升沿触发的寄存器，可以被如下实例化</p>
<div class="highlight"><pre><span></span><code>val reg = RegNext(in)
</code></pre></div>
<p>这个电路有的输出信号是延迟一个周期的输入信号 <code>in</code> 的复制。注意我们不需要指定这个寄存器的类型，它在这样实例化时，会通过他的输入自动推断出来。在当前版本的 Chisel 中，时钟和复位是被隐式包含在需要处的全局信号。</p>
<p>注意未指定初始值的寄存器在触发复位信号时不会发生变化。</p>
<p>通过寄存器，我们可以很快的定义许多有用的电路结构。例如，一个上升沿探测器，它可以结构一个布尔信号 <code>in</code> 并在当前值为真，之前值为假时输出 <code>true</code>，如下所示：</p>
<div class="highlight"><pre><span></span><code>def risingedge(x: Bool) = x &amp;&amp; !RegNext(x)
</code></pre></div>
<p>计数器时一种很重要的时序电路。构建一个向上计数器，计数值最大值 max，然后回到 0，我们写道：</p>
<div class="highlight"><pre><span></span><code>def counter(max: UInt) = {
  val x = RegInit(0.asUInt(max.getWidth.W))
  x := Mux(x === max, 0.U, x + 1.U)
}
</code></pre></div>
<p>计数器寄存器是在计数器函数中创建的，其重置值为 0（宽度足够大以保持最大值），当电路的全局重置被触发时，寄存器将被初始化。计数器中对 x 的 := 赋值连接了一个组合电路，该电路递增计数器值，当它达到最大值将返回 0。请注意，当 x 出现在赋值的右侧时，它的输出被引用，而当 x 显示在赋值的左侧时，其输入被引用。计数器可用于构建许多有用的时序电路。例如，我们可以通过在计数器达到 0 时输出true来构建脉冲发生器：</p>
<div class="highlight"><pre><span></span><code>// 每 n 周期产生脉冲
def pulse(n: UInt) = counter(n - 1.U) === 0.U
</code></pre></div>
<p>方波发生器可以通过脉冲串来实现，在每个脉冲翻转输出：</p>
<div class="highlight"><pre><span></span><code>// 输入为真时反转内部状态
def toggle(p: Bool) = {
  val x = RegInit(false.B)
  x := Mux(p, !x, x)
}
// 给定周期的方波
def squareWave(period: UInt) = toggle(pulse(period &gt;&gt; 1))
</code></pre></div>
<h1 id="memories">存储（Memories）<a class="headerlink" href="#memories" title="Permanent link">&para;</a></h1>
<p>Chisel 为创建只读存储和读/写存储提供了支持。</p>
<h2 id="rom">ROM<a class="headerlink" href="#rom" title="Permanent link">&para;</a></h2>
<p>用户可以通过 <code>VecInit</code> 构建一个 <code>Vec</code> 来定义一个只读存储。<code>VecInit</code> 能够接受 <code>Data</code> 字面值，也能接收初始化 ROM 的 <code>Seq[Data]</code>。</p>
<p>例如，用户可以创建一个初始化为 1，2，3，4，8 的小 ROM 并使用计数器作为地址生成器来遍历所有值：</p>
<div class="highlight"><pre><span></span><code>import chisel3._
import chisel3.util.Counter
val m = VecInit(1.U, 2.U, 3.U, 4.U, 8.U)
val c = Counter(m.length)
c.inc()
val r = m(c.value)
</code></pre></div>
<p>我们可以用如下初始化的 ROM 创建一个 <em>n</em> 值正弦查找表</p>
<div class="highlight"><pre><span></span><code>import chisel3._

val Pi = math.Pi

def sinTable(amp: Double, n:Int) = {
  val times = 
    (0 until n).map(i =&gt; (i*2*Pi)/(n.toDouble-1) - Pi)
  val inits = 
    times.map(t =&gt; Math.round(amp * math.sin(t).asSInt(32.W)))
  VecInit(inits)
}
</code></pre></div>
<p>在这里 <code>amp</code> 用来缩放存储在 ROM 中的定点值</p>
<h2 id="read-write-memories">读写存储（Read-Write Memories）<a class="headerlink" href="#read-write-memories" title="Permanent link">&para;</a></h2>
<p>存储在 Chise 中被特殊处理因为存储的硬件实现差异很大。比如 FPGA 的存储和 ASIC 的存储完全不同。Chisel 定义了存储的抽象，可以映射到任何简单的 Verilog 行为描述，也可以映射到 IP 厂商或代工厂提供的外部存储生成器生成的存储模块。</p>
<h3 id="ram-syncreadmem">同步读 RAM <code>SyncReadMem</code>：同步读取，同步写入<a class="headerlink" href="#ram-syncreadmem" title="Permanent link">&para;</a></h3>
<p>Chisel 对于同步读，同步写存储有一个叫 <code>SyncReadMem</code> 的结构。<code>SyncReadMem</code> 可能会被组成一个技术 SRAMs（而不是寄存器组）</p>
<p>如果在同一时钟沿上同时写入和顺序读取同一存储器地址，或者如果清除了顺序读取使能，则读取数据未定义。</p>
<p>读数据端口的值不能保证在下一个读取周期之前不改变。如果这是一个期望的行为，必须添加外部逻辑来保持上次读取的值。</p>
<h3 id="read-portwrite-port">读端口/写端口（Read port/write port）<a class="headerlink" href="#read-portwrite-port" title="Permanent link">&para;</a></h3>
<p><code>SyncReadMems</code> 是使用 UInt 索引创建的。有一个读端口和一个写端口的 1024 大小的 SRAM 可以被如下表达：</p>
<div class="highlight"><pre><span></span><code>import chisel3._
class ReadWriteSmem extends Module {
  val width: Int = 32
  val io = IO(new Bundle {
    val enable = Input(Bool())
    val write = Input(Bool())
    val addr = Input(Bool())
    val dataIn = Input(UInt(width.W))
    val dataOut = Output(UInt(width.W))
  })

  val mem = SyncReadMem(1024, UInt(width.W))
  // 创建一个读端口一个写端口
  mem.write(io.addr, io.datain)
  io.dataOut := mem.read(io.addr, io.enable)
}
</code></pre></div>
<p>下面是带掩码的一个写端口/一个读端口 <code>SyncReadMem</code> 的波形示例。信号名称与为 <code>SyncReadMem</code> 生成的导线名称不同。通过掩码的操作，也有可能生成具有以下行为的多个RTL阵列。</p>
<p><img alt="read-write ports example waveform" src="./Chisel 3 说明文档翻译 _ Light Blog_files/smem_read_write.png" /></p>
<h3 id="single-ported">单端口（Single-ported）<a class="headerlink" href="#single-ported" title="Permanent link">&para;</a></h3>
<p>当读和写条件在同一时间链中互斥时，可以推断出单端口SRAM：</p>
<div class="highlight"><pre><span></span><code>import chisel3._

class RWSmem extends Modules {
  val width: Int = 32
  val io = (new Bundle {
    val enable = Input(Bool())
    val write = Input(Bool())
    val addr = Input(Bool())
    val dataIn = Input(UInt(width.W))
    val dataOut = Output(UInt(width.W))
  })

  val mem = SyncReadMem(1024, UInt(width.W))
  io.dataOut := DontCare
  when(io.enable) {
    val rdwrPort = mem(io.addr)
    when (io.write) { rdwrPort := io.dataIn }
      .otherwise    { io.dataOut := rdwrPort }
  }
}
</code></pre></div>
<p>这里的 <code>DontCare</code> 是为了让 Chisel 的未连接线检测意识到边写边读是未定义的。）</p>
<p>以下是具有掩码的单个读/写端口波形的示例（同样，生成的信号名称和阵列数量可能不同）：</p>
<p><img alt="read/write ports example waveform" src="./Chisel 3 说明文档翻译 _ Light Blog_files/smem_rw.png" /></p>
<p>单端口SRAM也可以通过使用readWrite调用显式生成，该调用产生一个单读/写访问器，如下所示：</p>
<div class="highlight"><pre><span></span><code>class RDWR_Smem extends Module {
  val width: Int = 32
  val io = IO(new Bundle {
    val enable = Input(Bool())
    val write = Input(Bool())
    val addr = Input(UInt(10.W))
    val dataIn = Input(UInt(width.W))
    val dataOut = Output(UInt(width.W))
  })

  val mem = SyncReadMem(1024, UInt(width.W))
  io.dataOut := mem.readWrite(io.addr, io.dataIn, io.enable, io.write)
}
</code></pre></div>
<h3 id="mem"><code>Mem</code>: 异步读取，同步写入<a class="headerlink" href="#mem" title="Permanent link">&para;</a></h3>
<p>Chisel通过 <code>Mem</code> 结构支持随机存取存储器。对 <code>Mem</code> 的写入是组异步读取、同步写入。由于现代技术（FPGA、ASIC）中的大多数 SRAM 往往不再支持异步读取，因此这些 <code>Mem</code> 可能会被合成为寄存器组。</p>
<p>创建上面示例的异步读取版本只需将 <code>SyncReadMem</code> 替换为 <code>Mem</code>。</p>
<h2 id="masks">掩码（Masks）<a class="headerlink" href="#masks" title="Permanent link">&para;</a></h2>
<p>Chisel 存储器还支持子字的写掩码。如果存储的数据类型是向量，Chisel 将推断掩码。要推断掩码，需要指定创建写入端口的写入函数的掩码参数。如果设置了相应的掩码位，则写入给定的掩码长度。例如，在下面的例子中，如果掩码的第 0 位为真，它将把数据的较低字节写入相应的地址。</p>
<div class="highlight"><pre><span></span><code>import chisel3._
class MaskedReadWriteSmem extends Module {
  val width: Int = 8
  val io = IO(new Bundle {
    val enable = Input(Bool())
    val write = Input(Bool())
    val addr = Input(UInt(10.W))
    val mask = Input(Vec(4, Bool()))
    val dataIn = Input(Vec(4, UInt(width.W)))
    val dataOut = Output(Vec(4, UInt(width.W)))
  })

  // 创建一个字节掩码的 32 位宽的寸尺
  val mem = SyncReadMem(1024, Vec(4, UInt(width.W)))
  // 掩码写入
  mem.write(io.addr, io.dataIn, io.mask)
  io.dataOut := mem.read(io.addr, io.enable)
}
</code></pre></div>
<p>这是一个读写端口的掩码示例：</p>
<div class="highlight"><pre><span></span><code>import chisel3._
class MaskedRWSmem extends Module {
  val width: Int = 32
  val io = IO(new Bundle {
    val enable = Input(Bool())
    val write = Input(Bool())
    val mask = Input(Vec(2, Bool()))
    val addr = Input(UInt(10.W))
    val dataIn = Input(Vec(2, UInt(width.W)))
    val dataOut = Output(Vec(2, UInt(width.W)))
  })

  val mem = SyncReadMem(1024, Vec(2, UInt(width.W)))
  io.dataOut := DontCare
  when(io.enable) {
    val rdwrPort = mem(io.addr)
    when (io.write) {
      when(io.mask(0)) {
        rdwrPort(0) := io.dataIn(0)
      }
      when(io.mask(1)) {
        rdwrPort(1) := io.dataIn(1)
      }
    }.otherwise { io.dataOut := rdwrPort }
  }
}
</code></pre></div>
<h2 id="memory-initialization">存储初始化（Memory Initialization）<a class="headerlink" href="#memory-initialization" title="Permanent link">&para;</a></h2>
<p>Chisel存储器可以从外部二进制或十六进制文件初始化，该文件发出用于合成或模拟的正确Verilog。有多种初始化模式。</p>
<p>有关更多信息，请查看关于加载内存功能的<a href="https://www.chisel-lang.org/chisel3/docs/appendix/experimental-features#loading-memories">实验文档</a>。</p>
<h1 id="interfaces-connections">接口和连接（Interfaces &amp; Connections）<a class="headerlink" href="#interfaces-connections" title="Permanent link">&para;</a></h1>
<p>对于更复杂的模块，在定义模块的IO时定义和实例化接口类很有用。首先，也是最重要的，接口类促进重用，允许用户以有用的形式捕获一次性的通用接口。</p>
<p>第二，接口允许用户通过支持生产者和消费者模块之间的批量连接显著的减少布线。最后用户可以在一处地方对大型接口进行更改，减少添加或删除接口部分时的更新数量。</p>
<p>注意 Chisel 有一些内置的标准接口，应该尽量使用这些接口实现相互操作（比如，Decoupled）</p>
<h2 id="ports-subclasses-nesting">端口：子类和网络（Ports: Subclasses &amp; Nesting）<a class="headerlink" href="#ports-subclasses-nesting" title="Permanent link">&para;</a></h2>
<p>像我们之前看到的，用户可以通过定义 <code>Bundle</code> 的子类定义他们自己的接口。例如，用户可以如下定义一个握手数据的简单连接：</p>
<div class="highlight"><pre><span></span><code>class SimpleLink extends Bundle {
  val data = Output(UInt(16.W))
  val valid = Output(Bool())
}
</code></pre></div>
<p>我们可以扩展一个奇偶校验位。</p>
<div class="highlight"><pre><span></span><code>class PLink extends SimpleLink {
  val parity = Output(UInt(5.W))
}
</code></pre></div>
<p>通常，用户可以通过继承将他们的接口组织进层次结构中。</p>
<p>从那里，我们可以通过将两个 PLink 嵌套到一个新的 FilterIO 中来定义滤波器接口：
From there we can define a filter interface by nesting two PLinks into a new FilterIO bundle:</p>
<div class="highlight"><pre><span></span><code>class FilterIO extends Bundle {
  val x = Flipped(new PLink)
  val y = new PLink
}
</code></pre></div>
<p>在这里递归的翻转了接口的方向，将输入变为输出，输出变为输入。</p>
<p>我们现在可以使用 module 定义一个滤波器类。</p>
<div class="highlight"><pre><span></span><code>class Filter extends Module {
  val io = IO(new FilterIO)
  // ...
}
</code></pre></div>
<p>在 io 域中包含 FilterIO。</p>
<h2 id="bundle-vectors">Bundle Vectors<a class="headerlink" href="#bundle-vectors" title="Permanent link">&para;</a></h2>
<p>除了单个元素之外，元素的向量形成了更丰富的层次接口。例如，为了创建具有输入向量的交叉开关，产生输出向量，并由 UInt 输入选择，我们使用 Vec 构造函数：</p>
<div class="highlight"><pre><span></span><code>import chisel3.util.log2Ceil
class CrossbarIo(n: Int) extends Bundle {
  val in = Vec(n, Flipped(new PLink))
  val sel = Input(UInt(log2Ceil(n).W))
  val out = Vec(n, new PLink)
}
</code></pre></div>
<p>其中 Vec 将大小作为第一个参数，将返回端口的块作为第二个参数。</p>
<h2 id="bulk-connections">批量连接（Bulk Connections）<a class="headerlink" href="#bulk-connections" title="Permanent link">&para;</a></h2>
<p>一旦我们定义了接口，我们就能通过 <code>MonoConnect</code> 操作符（<code>:=</code>）或者 <code>Biconnect</code> 操作符（<code>&lt;&gt;</code>）连接到他。</p>
<h2 id="monoconnect-algorithm"><code>MonoConnect</code> Algorithm<a class="headerlink" href="#monoconnect-algorithm" title="Permanent link">&para;</a></h2>
<p><code>MonoConnect.connect</code>，或者 <code>:=</code>，按元素执行单向连接。</p>
<p>注意这不是可交换的。在调用之前已经确定了一个明确的源和汇。</p>
<p>这个连接操作将向下递归到左侧的 Data（带有右侧的 Data）。如果通过左侧的移动无法在右侧匹配，则会引发异常。右侧允许有额外的字段。Vec 的大小必须完全相同。</p>
<p>注意 LHS 元素必须是可写的，因此其中一个必须包含：</p>
<ul>
<li>是一个内部可写节点（Reg or Wire）</li>
<li>是一个当前模块的输出</li>
<li>是当前模块的子模块的输入</li>
</ul>
<p>注意 RHS 元素必须是可读的，其中一个必须包含：</p>
<ul>
<li>是一个内部可读节点（Reg, Wire, Op）</li>
<li>是字面量</li>
<li>是当前模块的端口或当前模块子模块的端口</li>
</ul>
<h2 id="biconnect-algorithm"><code>BiConnect</code> Algorithm<a class="headerlink" href="#biconnect-algorithm" title="Permanent link">&para;</a></h2>
<p><code>BiConnect.connect</code>，或者 <code>&lt;&gt;</code>，按元素执行双向连接。请注意，自变量是左和右（而不是源和汇），因此目的是使运算具有交换性。连接操作将向下递归到左侧的Data（带有右侧的Data）。如果左侧的移动无法在右侧匹配，或者右侧有额外的字段，则会引发异常。</p>
<p>注意：我们强烈建议使用 <code>Connectable</code> 操作符编写代码而不是使用 <code>&lt;&gt;</code>。</p>
<p>使用双向连接操作符 <code>&lt;&gt;</code>， 我们可以将两个滤波器组合成一个滤波器：</p>
<div class="highlight"><pre><span></span><code>class Block extends Module {
  val io = IO(new FilterIO)
  val f1 = Module(new Filter)
  val f2 = Module(new Filter)
  f1.io.x &lt;&gt; io.x
  f1.io.y &lt;&gt; f2.io.x
  f2.io.y &lt;&gt; io.y
}
</code></pre></div>
<p>双向批量连接操作符 <code>&lt;&gt;</code> 将同名的叶端口相互连接。Bundle 的 Scala 类型不需要匹配。如果一个命名的信号在另一侧不存在，Chisel 会像下面的示例一样报错：</p>
<div class="highlight"><pre><span></span><code>class NotReallyAFilterIO extends Bundle {
  val x = Flipped(new PLink)
  val y = new PLink
  val z = Output(new Bool())
}
class Block2 extends Module {
  val io1 = IO(new FilterIO)
  val io2 = IO(Flipped(new NotReallyAFilterIO))

  io1 &lt;&gt; io2
}
</code></pre></div>
<p>下面我们会看到这个示例的报错：</p>
<div class="highlight"><pre><span></span><code>ChiselStage.emitSystemVerilog(new Block2)
// chisel3.package$ChiselException: Connection between left (Block2.io1: IO[FilterIO]) and source (Block2.io2: IO[NotReallyAFilterIO]) failed @.z: Left Record missing field (z).
//  at ... ()
//  at repl.MdocSession$MdocApp$Block2.&lt;init&gt;(interfaces-and-connections.md:89)
//  at repl.MdocSession$MdocApp$$anonfun$22$$anonfun$apply$20.apply(interfaces-and-connections.md:97)
//  at repl.MdocSession$MdocApp$$anonfun$22$$anonfun$apply$20.apply(interfaces-and-connections.md:97)
//  at ... ()
//  at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace)
</code></pre></div>
<p>双向连接应仅与**定向元素**（如 IO）一起使用，例如不支持连接两条线，因为 Chisel 不一定能自动确定方向。例如，放置两条临时电线并在此处连接它们是行不通的，即使从端点可以知道方向：</p>
<div class="highlight"><pre><span></span><code>class BlockWithTemporaryWires extends Module {
  val io = IO(new FilterIO)
  val f1 = Module(new Filter)
  val f2 = Module(new Filter)
  f1.io.x &lt;&gt; io.x
 val tmp1 = Wire(new FilterIO)
 val tmp2 = Wire(new FilterIO)
  f1.io.y &lt;&gt; tmp1
  tmp1 &lt;&gt; tmp2
  tmp2 &lt;&gt; f2.io.x
  f2.io.y &lt;&gt; io.y
}
</code></pre></div>
<p>下面我们会看到这个示例的报错：</p>
<div class="highlight"><pre><span></span><code>ChiselStage.emitSystemVerilog(new BlockWithTemporaryWires)
// chisel3.package$ChiselException: Connection between left (Filter.io.y: IO[PLink]) and source (BlockWithTemporaryWires.tmp1: Wire[FilterIO]) failed @.y: Left Record missing field (y).
//  at ... ()
//  at repl.MdocSession$MdocApp$BlockWithTemporaryWires.&lt;init&gt;(interfaces-and-connections.md:113)
//  at repl.MdocSession$MdocApp$$anonfun$33$$anonfun$apply$29.apply(interfaces-and-connections.md:124)
//  at repl.MdocSession$MdocApp$$anonfun$33$$anonfun$apply$29.apply(interfaces-and-connections.md:124)
//  at ... ()
//  at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace)
</code></pre></div>
<p>有关详细信息和信息，请参阅深入了解连接操作符</p>
<p>注意：当使用 <code>Chisel._</code>（兼容模式）而不是 <code>chisel3._</code> 时，<code>:=</code> 操作符以类似于 <code>&lt;&gt;</code> 的双向方式工作，但不完全相同。</p>
<h2 id="the-standard-ready-valid-interface-readyvalidio-decoupled">The standard ready-valid interface (ReadyValidIO / Decoupled)<a class="headerlink" href="#the-standard-ready-valid-interface-readyvalidio-decoupled" title="Permanent link">&para;</a></h2>
<p>Chisel 为 ready-valid 接口提供了标准接口。就绪有效接口由就绪信号、有效信号和一些存储在位中的数据组成。就绪位表示消费者已准备好消费数据。有效位指示生产者在位上具有有效数据。当 <code>ready</code> 和 <code>valid</code> 都被断言时，就会发生从生产者到消费者的数据传输。提供了一个方便的方法 <code>fire</code>，如果 <code>ready</code> 和 <code>valid</code> 都被断言，它就会被断言。</p>
<p>通常，我们使用函数 <code>Decoupled()</code> 将任何类型转换为就绪有效接口，而不是直接使用 ReadyValidIO。</p>
<ul>
<li><code>Decoupled(...)</code> 创建一个生产者/输出就绪有效接口（即位是一个输出）。</li>
<li><code>Flipped(Decoupled(...))</code> 创建一个消费者/输入就绪有效接口（即位是输入）。</li>
</ul>
<p>查看以下示例 Chisel 代码，以更好地理解生成的内容：</p>
<div class="highlight"><pre><span></span><code>import chisel3._
import chisel3.util.Decoupled

/**
  * Using Decoupled(...) creates a producer interface.
  * i.e. it has bits as an output.
  * This produces the following ports:
  *   input         io_readyValid_ready,
  *   output        io_readyValid_valid,
  *   output [31:0] io_readyValid_bits
  */
class ProducingData extends Module {
  val io = IO(new Bundle {
    val readyValid = Decoupled(UInt(32.W))
  })
  // do something with io.readyValid.ready
  io.readyValid.valid := true.B
  io.readyValid.bits := 5.U
}

/**
  * Using Flipped(Decoupled(...)) creates a consumer interface.
  * i.e. it has bits as an input.
  * This produces the following ports:
  *   output        io_readyValid_ready,
  *   input         io_readyValid_valid,
  *   input  [31:0] io_readyValid_bits
  */
class ConsumingData extends Module {
  val io = IO(new Bundle {
    val readyValid = Flipped(Decoupled(UInt(32.W)))
  })
  io.readyValid.ready := false.B
  // do something with io.readyValid.valid
  // do something with io.readyValid.bits
}
</code></pre></div>
<p><code>DecoupledIO</code> 是一个就绪有效的接口，其约定不保证解除断言就绪或有效或位的稳定性。这意味着 <code>ready</code> 和 <code>valid</code> 也可以在没有数据传输的情况下取消断言。</p>
<p><code>IrrevocableIO</code> 是一个 ready-valid 接口，其约定是在 <code>valid</code> 被断言和 <code>ready</code> 被取消断言时，位的值不会改变。此外，消费者应在 <code>ready</code> 为高且 <code>valid</code> 为低的周期后保持 <code>ready</code> 断言。请注意，不可撤销的约束只是一个约定，不能由接口强制执行。 Chisel 不会自动生成检查器或断言来强制执行不可撤销的约定。</p>
<h1 id="blackboxes">BlackBoxes<a class="headerlink" href="#blackboxes" title="Permanent link">&para;</a></h1>
<p>Chisel 的 <em>BlackBoxes</em> 被用来实例化外部定义的模块。这个结构在使用不能被 Chisel 描述的硬件结构和连接到 FPGA 或其他没有使用 Chisel 定义的模块时很有用。</p>
<p>被定义为 <code>BlackBox</code> 的模块会在生成的 Verilog 中被实例化，但是不会生成定义模块行为的代码。</p>
<p>和 <code>Module</code> 不同，<code>BlackBox</code> 没有隐式时钟和复位。<code>BlackBox</code> 的时钟和复位端口要显示声明并连接到输入信号。在 IO Bundle 中声明的端口将会被生成为所需的名称（没有 <code>io_</code> 前缀）。</p>
<h2 id="_1">参数化<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<p>Verilog 参数可以作为参数传递给 BlackBox 构造函数。</p>
<p>例如，考虑在 Chisel 设计中实例化 Xilinx 差分时钟缓冲器 (IBUFDS)：</p>
<div class="highlight"><pre><span></span><code>import chisel3._
import chisel3.util
import chisel3.experiment._

class IBUFDS extends BlackBox(Map(&quot;DIFF_TERM&quot;-&gt;&quot;True&quot;, 
                                  &quot;IOSTANDARD&quot;-&gt;&quot;DEFAULT&quot;)) {
  val io = IO(new Bundle {
    val O = Output(Clock())
    val I = Input(Clock())
    val IB = Input(Clock())
  })
}

class TOP extends Module {
  val io = IO(new Bundle {})
  val ibufds = Module(new IBUFDS)
  ibufds.io.I :=clock
}
</code></pre></div>
<p>在 chisel 生成的 Verilog 代码中，<code>IBUFDS</code> 将会被实例化为：</p>
<div class="highlight"><pre><span></span><code>IBUFDS #(.DIFF_TERM(&quot;TRUE&quot;), .IOSTANDARD(&quot;DEFAULT&quot;)) ibufds (
  .IB(ibufds_IB)
  .I(ibufds_I)
  .O(ibufds_O)
);
</code></pre></div>
<h2 id="blackboxes_1">提供实现的 BlackBoxes<a class="headerlink" href="#blackboxes_1" title="Permanent link">&para;</a></h2>
<p>Chisel 提供了以下方式来提供黑盒底层的代码。考虑以下将两个实数相加的黑盒。这些数字在 chisel3 中表示为 64 位无符号整数。</p>
<div class="highlight"><pre><span></span><code>import chisel3._

class BlackBoxRealAdd extends BlackBox {
  val io = IO(new Bundle {
    val in1 = Input(UInt(64.W))
    val in2 = Input(UInt(64.W))
    val out = Output(UInt(64.W))
  })
}
</code></pre></div>
<p>这个例子实现的例子如下面的 Verilog 代码描述：</p>
<div class="highlight"><pre><span></span><code>module BlackBoxAdd(
  input [63:0] in1,
  input [63:0] in2,
  output [63:0] out
);

always @* begin
  out &lt;= $realtobits($bitstoreal(in1) + $bitstoreal(in2));
end

endmodule
</code></pre></div>
<h2 id="verilog-blackboxes">Verilog 在资源文件中的 BlackBoxes<a class="headerlink" href="#verilog-blackboxes" title="Permanent link">&para;</a></h2>
<p>为了将上述代码传递到后端模拟器，chisel3 提供了基于 chisel/firrtl 注释系统的如下工具。在声明中添加 <code>HasBlackBoxResource</code> 特征，然后调用一个函数来告知系统在哪里可以找到 verilog。这个模块如下所示：</p>
<div class="highlight"><pre><span></span><code>import chisel3._

class BlackBoxRealAdd extends BlackBox {
  val io = IO(new Bundle {
    val in1 = Input(UInt(64.W))
    val in2 = Input(UInt(64.W))
    val out = Output(UInt(64.W))
  })
setResource(&quot;/real_math.v&quot;)
}
</code></pre></div>
<p>上述 verilog 代码放置在 <code>real_math.v</code> 文件中。什么是资源文件？它来自于将文件保存在项目中的 java 约定，这些文件会自动包含在库发行版中。在一个典型的 Chisel3 工程中（参考 <a href="https://github.com/freechipsproject/chisel-template">chisel-template</a>），这会是源文件层次结构中的一个目录：<code>src/main/resource/real_math.v</code>。</p>
<h2 id="verilog-blackboxes_1">内联 Verilog 的 BlackBoxes<a class="headerlink" href="#verilog-blackboxes_1" title="Permanent link">&para;</a></h2>
<p>我们也可以直接把 Verilog 代码放入 scala 源文件。使用 <code>HasBlackBoxInline</code> 替换掉 <code>HasBlackBoxResource</code>，然后用 <code>setinline</code> 替换掉 <code>setResource</code>。代码如下所示：</p>
<div class="highlight"><pre><span></span><code>import chisel3._
import chisel3.util.HasBlackBoxInline
class BlackBoxRealAdd extends BlackBox with HasBlackBoxInline {
  val io = IO(new Bundle {
    val in1 = Input(UInt(64.W))
    val in2 = Input(UInt(64.W))
    val out = Output(UInt(64.W))
  })
  setInline(&quot;BlackBoxRealAdd.v&quot;,
    &quot;&quot;&quot;module BlackBoxRealAdd(
      |    input  [15:0] in1,
      |    input  [15:0] in2,
      |    output [15:0] out
      |);
      |always @* begin
      |  out &lt;= $realtobits($bitstoreal(in1) + $bitstoreal(in2));
      |end
      |endmodule
    &quot;&quot;&quot;.stripMargin)
}
</code></pre></div>
<p>该技术会将内联 verilog 复制到目标目录的 <code>BlackBoxRealAdd.v</code> 文件中。</p>
<h2 id="_2">引擎之下<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<p>这种将 verilog 内容传递到测试后端的机制是通过 chisel/firrtl 注释实现的。 inline 和 resources 这两种方法是通过 <code>setInline</code> 和 <code>setResource</code> 方法调用创建的两种注释。这些注释会传递给 chisel 测试人员，然后 chisel 测试人员会将它们传递给 firrtl。默认的 firrtl verilog 编译器有一个过程，可以检测注释并将文件或内联测试移动到构建目录中。对于添加的每个唯一文件，转换会向文件 black_box_verilog_files.f 添加一行，该文件将添加到为 verilator 或 vcs 构建的命令行中，以通知它们要查找的位置。<a href="https://github.com/ucb-bar/dsptools">dsptools</a> 项目是使用此功能构建基于黑匣子的实数模拟测试器的一个很好的例子。</p>
<h1 id="chisel-chiselenum">Chisel 枚举（ChiselEnum）<a class="headerlink" href="#chisel-chiselenum" title="Permanent link">&para;</a></h1>
<p>ChiselEnum 类型经常被用来减少编码选择器，操作码和功能单元操作的出错机会。与 <code>Chisel.util.Enum</code> 相比，<code>ChiselEnum</code> 是 <code>Data</code> 的子类，这意味着它可以用于定义 <code>Bundle</code> 中的字段，包括 <code>IO</code> 中的字段。</p>
<h2 id="_3">功能和示例<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code>// 在后续实例中用到的 import
import circt.stage.ChiselStage
import chisel3._
import chisel3.util._
</code></pre></div>
<p>下面我们看到 ChiselEnum 被用作 RISC-V 内核的多路复用器选择信号。虽然不需要将对象包装在包中，但强烈建议这样做，因为它允许更轻松地在多个文件中使用该类型。</p>
<div class="highlight"><pre><span></span><code>// package CPUTypes {
object AluMux1Sel extends ChiselEnum {
  val selectRS1, selectPC = value
}
// 我们可以通过打印所有值来查看映射
AluMux1Sel.all.foreach(println)
// AluMux1Sel(0=selectRS1)
// AluMux1Sel(1=selectPC)
</code></pre></div>
<p>这里我们可以看到选择器使用 AluMux1Sel 来选择不同的输入。</p>
<div class="highlight"><pre><span></span><code>import AluMux1Sel._

class AluMux1Bundle extends Bundle {
  val AluMux1Sel = Input(AluMux1Sel())
  val rs1Out     = Input(Bits(32.W))
  val pcOut      = Input(Bits(32.W))
  val aluMuxOut  = Output(Bits(32.W))
}

class AluMux1File extends Module {
  val io = IO(new AluMux1Bundle)
  io.aluMuxOut := 0.U

  switch(io.AluMux1Sel) {
    is (selectRS1) {
      io.aluMux1Out := io.rs1Out
    }
    is (selectPC) {
      io.aluMux1Out := io.pcOut
    }
  }
}
// Generated by CIRCT firtool-1.44.0
module AluMux1File( // &lt;stdin&gt;:17:10
  input         clock,  // &lt;stdin&gt;:18:11
                reset,  // &lt;stdin&gt;:19:11
                io_aluMux1Sel,  // chisel-enum.md:63:14
  input  [31:0] io_rs1Out,  // chisel-enum.md:63:14
                io_pcOut,   // chisel-enum.md:63:14
  output [31:0] io_aluMux1Out   // chisel-enum.md:63:14
);

  assign io_aluMux1Out = io_aluMux1Sel ? io_pcOut : io_rs1Out;  // &lt;stdin&gt;:17:10, chisel-enum.md:68:26, :70:21
endmodule
</code></pre></div>
<p>ChiselEnum 也允许用户像如下所示的方式给 <code>Value(...)</code> 直接传递 <code>UInt</code> 来设定值。注意，每个 <code>Value</code> 的大小必须严格大于前一个。</p>
<div class="highlight"><pre><span></span><code>object Opcode extends ChiselEnum {
    val load  = Value(0x03.U) // i &quot;load&quot;  -&gt; 000_0011
    val imm   = Value(0x13.U) // i &quot;imm&quot;   -&gt; 001_0011
    val auipc = Value(0x17.U) // u &quot;auipc&quot; -&gt; 001_0111
    val store = Value(0x23.U) // s &quot;store&quot; -&gt; 010_0011
    val reg   = Value(0x33.U) // r &quot;reg&quot;   -&gt; 011_0011
    val lui   = Value(0x37.U) // u &quot;lui&quot;   -&gt; 011_0111
    val br    = Value(0x63.U) // b &quot;br&quot;    -&gt; 110_0011
    val jalr  = Value(0x67.U) // i &quot;jalr&quot;  -&gt; 110_0111
    val jal   = Value(0x6F.U) // j &quot;jal&quot;   -&gt; 110_1111
}
</code></pre></div>
<p>用户可以“跳转”到某个值，并通过传递起点然后使用常规值定义来继续递增。</p>
<div class="highlight"><pre><span></span><code>object BranchFunct3 extends ChiselEnum {
  val beq, bne = Value
  val blt = Value(4.U)
  val bge, bltu, bgeu = Value
}

// 我们可以通过打印所有值来查看映射
BranchFunct3.all.foreach(println)
// BranchFunct3(0=beq)
// BranchFunct3(1=bne)
// BranchFunct3(4=blt)
// BranchFunct3(5=bge)
// BranchFunct3(6=bltu)
// BranchFunct3(7=bgeu)
</code></pre></div>
<h2 id="_4">类型转换<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h2>
<p>你可以用 <code>.asUInt</code> 把枚举类型转换为 <code>UInt</code>：</p>
<div class="highlight"><pre><span></span><code>class ToUInt extends RawModule {
  val in = IO(Input(Opcode()))
  val out = IO(Output(UInt()))
  out := in.asUInt
}
</code></pre></div>
<p>你也可以将 <code>UInt</code> 传递给 <code>ChiselEnum</code> 的 apply 方法来将其转换为枚举类型：</p>
<div class="highlight"><pre><span></span><code>class FromUInt extends Module {
  val in = IO(Input(UInt(7.W)))
  val out = IO(Output(Opcode()))
  out := Opcode(in)
}
</code></pre></div>
<p>但是，如果在 <code>UInt</code> 可能遇到的枚举值中存在未定义状态时从 <code>UInt</code> 转换为枚举类型，您将看到如下警告：</p>
<div class="highlight"><pre><span></span><code>[warn] chisel-enum.md:136:16: Casting non-literal UInt to repl.MdocSession$MdocApp$Opcode. You can use repl.MdocSession$MdocApp$Opcode.safe to cast without this warning.
[warn] There were 1 warning(s) during hardware elaboration.
</code></pre></div>
<p>（请注意，作为我们的文档生成流程的产物，枚举的名称很难看，在正常使用中它会更干净）。</p>
<p>您可以通过使用 <code>.safe</code> 工厂方法来避免此警告，该方法除了指示枚举是否处于有效状态的 <code>Bool</code> 之外，还返回强制转换枚举类型：</p>
<div class="highlight"><pre><span></span><code>class SafeFromUInt extends Module {
  val in = IO(Input(UInt(7.W)))
  val out = IO(Output(Opcode()))
  val (value, valid) = Opcode.safe(in)
  assert(valid, &quot;Enum state must be valid, got %d!&quot;, in)
  out := value
}
</code></pre></div>
<p>现在将不再有警告。</p>
<p>你也可以用 <code>suppressEnumCastWarning</code> 来抑制警告。这通常用于将 <code>UInt</code> 转换为包含枚举类型的 Bundle 类型，这里 <code>UInt</code> 是已知的合法的。</p>
<div class="highlight"><pre><span></span><code>class MyBundle extends Bundle {
  val addr = UInt(8.W)
  val op = Opcode()
}

class SuppressedFromUInt extends Module {
  val io = IO(Input(UInt(15.W)))
  val out = IO(Output(new MyBundle()))
  suppressedEnumCastWarning {
    out := in.asTypeOf(new MyBundle)
  }
}
</code></pre></div>
<h2 id="_5">测试<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h2>
<p>枚举值的类型是 <code>&lt;ChiselEnum Object&gt;.Type</code>，它可用于将值作为参数传递给函数（或任何其他需要类型注释的时候）。对枚举值调用 <code>.litValue</code> 将返回该对象的 <code>BigInt</code> 整数值。</p>
<div class="highlight"><pre><span></span><code>def expectedSel(sel: AluMux1Sel.Type): Boolean = sel match {
  case AluMux1Sel.selectRS1 =&gt; (sel.litValue == 0)
  case AluMux1Sel.selectPC  =&gt; (sel.litValue == 1)
  case _                    =&gt; false
}
</code></pre></div>
<p>枚举类型也定义了一些简便的方法来使用 <code>ChiselEnum</code> 值。例如，仍然使用 RISC-V 的操作码示例，可以使用 <code>.isOneOf</code> 方法轻松的创建仅在 LOAD/STORE 操作（当枚举值等于 <code>Opcode.load</code> 和 <code>Opcode.store</code> 时）上断言的硬件信号。</p>
<div class="highlight"><pre><span></span><code>class LoadStoreExample extends Module {
  val io = IO(new Bundle {
    val opcode = Input(Opcode())
    val load_or_store = Output(Bool())
  })
  io.load_or_store := io.opcode.isOneOf(Opcode.load, Opcode.store)
}
</code></pre></div>
<p><code>Chisel.Enum</code> 定义的一些有用的其他方法是：</p>
<ul>
<li><code>.all</code>：返回枚举中的枚举值</li>
<li><code>.getWidth</code>：返回一个硬件类型的宽度</li>
</ul>
<h2 id="_6">解决问题<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h2>
<p>自 Chisel v3.4.3（2020 年 7 月 1 号）起，值的宽度都是被推断的，你可以添加一个额外的值来强制规定一个宽度，像下面例子这样，添加了 <code>ukn</code> 来强制使位宽为 3。</p>
<div class="highlight"><pre><span></span><code>object StoreFunct3 extends ChiselEnum {
  val sb, sh, sw = Value
  val ukn = Value(7.U)
}
// 我们可以通过打印所有值来查看映射
StoreFunct3.all.foreach(println)
// StoreFunct3(0=sb)
// StoreFunct3(1=sh)
// StoreFunct3(2=sw)
// StoreFunct3(7=ukn)
</code></pre></div>
<p>不支持带符号的值，因此如果您想要带符号的值，则必须使用 <code>.asSInt</code> 转换 <code>UInt</code>。</p>
<h2 id="_7">其他资源<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h2>
<p>ChiselEnum 类型比上面所述的功能强大得多。它允许进行 Sequence、Vec 和 Bundle 分配，以及允许逐步执行顺序状态的 <code>.next</code> 操作和用于检查硬件值是否为有效值的 <code>.isValid</code>。 ChiselEnum 的源代码可以在 <code>EnumFactory</code> 类中找到。 ChiselEnum 操作的示例可以在<a href="https://github.com/chipsalliance/chisel/blob/dd6871b8b3f2619178c2a333d9d6083805d99e16/src/test/scala/chiselTests/StrongEnum.scala">此处</a>找到。</p>
<h1 id="dataview">DataView<a class="headerlink" href="#dataview" title="Permanent link">&para;</a></h1>
<p><em>Chisel 3.5 中的新功能</em></p>
<h2 id="_8">介绍<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h2>
<p>DataView 是一种将 Scala 对象 “viewing” 作为 chisel3.Data 子类型的机制。通常，这对于将 chisel3.Data 的一个子类型查看为另一种子类型很有用。人们可以将 DataView 视为从 <em>Target</em> 类型 <code>T</code> 到 <em>View</em> 类型 <code>V</code> 的映射。这类似于强制转换（例如 <code>.asTypeOf</code>），但有一些差异：</p>
<ol>
<li>View 是可连接的 —— 到 view 的连接发生目标上</li>
<li>强制转换是结构性的（对底层位的重新解释），而 DataView 是可自定义的映射</li>
<li>View 可以只有一部分 —— 不是目标所有的字段都要包含在映射中</li>
</ol>
<h2 id="axi4">一个使用示例（AXI4）<a class="headerlink" href="#axi4" title="Permanent link">&para;</a></h2>
<p>AXI4 是一个数字设计中常用的接口。使用 AXI4 的典型 Verilog 外设将写通道定义成下面这样：</p>
<div class="highlight"><pre><span></span><code>module my_module(
  input        AXI_AWVALID,
  output       AXI_AWREADY,
  input [3:0]  AXI_AWID,
  input [19:0] AXI_AWADDR,
  input [1:0]  AXI_AWLEN,
  input [1:0]  AXI_AWSIZE,
  // ...
);
</code></pre></div>
<p>这将对应于以下 Chisel 代码：</p>
<div class="highlight"><pre><span></span><code>class VerilogAXIBundle(val addrWidth: Int) extends Bundle {
  val AWVALID = Output(Bool())
  val AWREADY = Input(Bool())
  val AWID    = Output(UInt(4.W))
  val AWADDR  = Output(UInt(addrwidth.W))
  val AWLEN   = Output(UInt(2.W))
  val AWSIZE  = Output(UInt(2.W))
  // ...
}

// 实例化
class my_module extends RawModule {
  val AXI = IO(new VerilogAXIBundle(20))
}
</code></pre></div>
<p>在 Chisel 设计中用 <code>BlackBoxes</code> 实例化 Verilog 模块时，表达标准的 Verilog 接口是很重要的。但是一般来说，Chisel 开发者更喜欢通过 <code>Decoupled</code> 这样的程序来使用组合，而不是像上面那样单独处理 <code>valid</code> 和 <code>ready</code>。一个更 “Chisel-y” 的实现方式如下所示：</p>
<div class="highlight"><pre><span></span><code>// 注意 AW 与 AR 通道相似，可以使用相同的 Bundle 定义
class AXIAddressChannel(val addrwidth: Int) extends Bundle {
  val id   = UInt(4.W)
  val addr = UInt(addrwidth.W)
  val len  = UInt(2.W)
  val size = UInt(2.W)
  // ...
}

import chisel3.util.Decoupled
// 我们可以将各个 AXI 通道组合在一起
class AXIBundle(val addrwidth: Int) extends Bundle {
  val aw = Decoupled(new AXIAddressChannel(addrwidth))
  // val ar = new AXIAddressChannel
  // ...
}

class MyModule extends RawModule {
  val axi = IO(new AXIBundle(20))
}
</code></pre></div>
<p>当然，这会生成非常不同的 Verilog 代码：</p>
<div class="highlight"><pre><span></span><code>// Generated by CIRCT firtool-1.44.0
module MyModule(    // &lt;stdin&gt;:3:10
  input         axi_aw_ready,   // dataview.md:53:15
  output        axi_aw_valid,   // dataview.md:53:15
  output [3:0]  axi_aw_bits_id, // dataview.md:53:15
  output [19:0] axi_aw_bits_addr,   // dataview.md:53:15
  output [1:0]  axi_aw_bits_len,    // dataview.md:53:15
                axi_aw_bits_size    // dataview.md:53:15
);

  assign axi_aw_valid = 1&#39;h0;   // &lt;stdin&gt;:3:10, dataview.md:62:7
  assign axi_aw_bits_id = 4&#39;h0; // &lt;stdin&gt;:3:10, dataview.md:62:7
  assign axi_aw_bits_addr = 20&#39;h0;  // &lt;stdin&gt;:3:10, dataview.md:62:7
  assign axi_aw_bits_len = 2&#39;h0;    // &lt;stdin&gt;:3:10, dataview.md:62:7
  assign axi_aw_bits_size = 2&#39;h0;   // &lt;stdin&gt;:3:10, dataview.md:62:7
endmodule
</code></pre></div>
<p>那么我们该如何使用更结构化的类型，同时又保留预期的 Verilog 接口呢？看看 DataView：</p>
<div class="highlight"><pre><span></span><code>import chisel3.experiment.dataview._

//我们建议将 DataView 放入所涉及类型之一的伴生对象中
object AXIBundle {
  // 不用害怕使用 implicit，我们会在之后详细讨论这部分
  implicit val axiView = DataView[VerilogAXIBundle, AXIBundle](
    // 第一个参数是从目标类型的对象（VerilogAXIBundle）
    // 构造一个 View 类型的对象（AIXBundle）
    vab =&gt; new AXIBundle(vab.addrwidth),
    // 其余参数是两种类型字段的映射
    _.AWVALID -&gt; _.aw.valid,
    _.AWREADY -&gt; _.aw.ready,
    _.AWID    -&gt; _.aw.bits.id,
    _.AWADDR  -&gt; _.aw.bits.addr,
    _.AWLEN   -&gt; _.aw.bits.len,
    _.AWSIZE  -&gt; _.aw.bits.size,
    // ...
  )
}
</code></pre></div>
<p>这个 <code>DataView</code> 是 Verilog 风格的 AXI Bundle 和更具组合性的 Chisel 风格的 AXI Bundle 之间的映射。它允许我们定义我们的端口来匹配 Verilog 的接口，同时像更结构化的类型一样操作他：</p>
<div class="highlight"><pre><span></span><code>class AXIStub extends RawModule {
  val AXI = IO(new VerilogAXIBundle(20))
  val view = AXI.viewAs[AXIBundle]

  // 我们可以通过 `view` 操作 `AXI`
  view.aw.bits := 0.U.asTypeOf(new AXIAddressChannel(20)) // 默认将所有内容置零
  view.aw.valid ：= true.B
  when (view.aw.ready) {
    view.aw.bits.id := 5.U
    view.aw.bits.addr := 1234.U
    // 我们仍然可以像这样操作 AXI
    AXI.AWLEN := 1.U
  }
}
</code></pre></div>
<p>这会生成匹配标准命名约定的 Verilog 代码：</p>
<div class="highlight"><pre><span></span><code>// Generated by CIRCT firtool-1.44.0
module AXIStub( // &lt;stdin&gt;:3:10
  input         AXI_AWREADY,    // dataview.md:94:15
  output        AXI_AWVALID,    // dataview.md:94:15
  output [3:0]  AXI_AWID,   // dataview.md:94:15
  output [19:0] AXI_AWADDR, // dataview.md:94:15
  output [1:0]  AXI_AWLEN,  // dataview.md:94:15
                AXI_AWSIZE  // dataview.md:94:15
);

  assign AXI_AWVALID = 1&#39;h1;    // &lt;stdin&gt;:3:10, dataview.md:99:17
  assign AXI_AWID = AXI_AWREADY ? 4&#39;h5 : 4&#39;h0;  // &lt;stdin&gt;:3:10, dataview.md:98:{16,31}, :100:24, :101:21
  assign AXI_AWADDR = AXI_AWREADY ? 20&#39;h4D2 : 20&#39;h0;    // &lt;stdin&gt;:3:10, dataview.md:98:{16,31}, :100:24, :102:23
  assign AXI_AWLEN = {1&#39;h0, AXI_AWREADY};   // &lt;stdin&gt;:3:10, dataview.md:98:16, :100:24, :104:15
  assign AXI_AWSIZE = 2&#39;h0; // &lt;stdin&gt;:3:10, dataview.md:98:31
endmodule
</code></pre></div>
<p>注意，<em>目标类型</em> 和 <em>View 类型*都是 <code>Data</code> 类型的子类型，<code>DataView</code> 是*可逆的</em>。这意味着我们可以轻松的从已有的 <code>DataView[VerilogAXIBundle, AXIBundle]</code> 中创建一个 <code>DataView[AXIBundle, VerilogAXIBundle]</code>，我们需要做的是提供一个函数从 <code>AXIBundle</code> 的实例创建一个 <code>VerilogAXIBundle</code>：</p>
<div class="highlight"><pre><span></span><code>// 注意通常你需要把他们定义在一起（在 AXIBundle 对象中）
implicit val axiView2 = AXIBundle.axiView.invert(ab =&gt; new VerilogAXIBundle(ab.addrwidth))
</code></pre></div>
<p>下面的示例展示了这个并且说明了 <code>DataView</code> 的另一个使用情况 —— 连接不相关的类型：</p>
<div class="highlight"><pre><span></span><code>class ConnectionExample extends RawModule {
  val in = IO(new AXIBundle(20))
  val out = IO(Flipped(new VerilogAXIBundle(20)))

  out.viewAs[AXIBundle] &lt;&gt; in
}
</code></pre></div>
<p>这个结果会使 Verilog 中的字段相连接：</p>
<div class="highlight"><pre><span></span><code>// Generated by CIRCT firtool-1.44.0
module ConnectionExample(   // &lt;stdin&gt;:3:10
  input         in_aw_ready,    // dataview.md:125:14
                out_AWVALID,    // dataview.md:126:15
  input  [3:0]  out_AWID,   // dataview.md:126:15
  input  [19:0] out_AWADDR, // dataview.md:126:15
  input  [1:0]  out_AWLEN,  // dataview.md:126:15
                out_AWSIZE, // dataview.md:126:15
  output        in_aw_valid,    // dataview.md:125:14
  output [3:0]  in_aw_bits_id,  // dataview.md:125:14
  output [19:0] in_aw_bits_addr,    // dataview.md:125:14
  output [1:0]  in_aw_bits_len, // dataview.md:125:14
                in_aw_bits_size,    // dataview.md:125:14
  output        out_AWREADY // dataview.md:126:15
);

  assign in_aw_valid = out_AWVALID; // &lt;stdin&gt;:3:10
  assign in_aw_bits_id = out_AWID;  // &lt;stdin&gt;:3:10
  assign in_aw_bits_addr = out_AWADDR;  // &lt;stdin&gt;:3:10
  assign in_aw_bits_len = out_AWLEN;    // &lt;stdin&gt;:3:10
  assign in_aw_bits_size = out_AWSIZE;  // &lt;stdin&gt;:3:10
  assign out_AWREADY = in_aw_ready; // &lt;stdin&gt;:3:10
endmodule
</code></pre></div>
<h2 id="_9">其他示例<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h2>
<p>虽然像 AXI 实例中那样在 <code>Bundle</code> 类型之间映射的能力十分引人注目。但 DataView 还有很多其他应用。最重要的，因为 <code>DataView</code> 的*目标类型*不一定是 <code>Data</code>，所以他提供了一种使用需要 <code>Data</code> 的 API 获取 <code>non-Data</code> 对象的方法。</p>
<h2 id="tuple">元组（Tuple）<a class="headerlink" href="#tuple" title="Permanent link">&para;</a></h2>
<p>也许最有效的为 <code>non-Data</code> 使用 <code>DataView</code> 的方式就是将 Scala 的元组视为 <code>Bundle</code>。举个例子，在包含 <code>DataView</code> 之前的 Chisel，有人可能会尝试 <code>Mux</code> 元组然后收到下面的报错：</p>
<div class="highlight"><pre><span></span><code>class TupleExample extends RawModule {
  val a, b, c, d = IO(Input(UInt(8.W)))
  val cond = IO(Input(Bool()))
  val x, y = IO(Output(UInt(8.W)))
  (x, y) := Mux(cond, (a, b), (c, d))
}
// error: value := is not a member of (chisel3.UInt, chisel3.UInt)
//   Expression does not convert to assignment because receiver is not assignable.
//   (x, y) := Mux(cond, (a, b), (c, d))
//   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// error: inferred type arguments [(chisel3.UInt, chisel3.UInt)] do not conform to macro method apply&#39;s type parameter bounds [T &lt;: chisel3.Data]
//   (x, y) := Mux(cond, (a, b), (c, d))
//             ^^^
// error: type mismatch;
//  found   : (chisel3.UInt, chisel3.UInt)
//  required: T
//   (x, y) := Mux(cond, (a, b), (c, d))
//                       ^^^^^^
// error: type mismatch;
//  found   : (chisel3.UInt, chisel3.UInt)
//  required: T
//   (x, y) := Mux(cond, (a, b), (c, d))
//                               ^^^^^^
</code></pre></div>
<p>这个问题是因为像 <code>Mux</code> 和 <code>:=</code> 这样的 Chisel 原语只操作 <code>Data</code> 和元组的子类型（作为 Scala 标准库的成员），而不是 <code>Data</code> 的子类。<code>DataView</code> 提供了一种*查看* <code>Tuple</code> 的机制，就好像他是 <code>Data</code> 一样：</p>
<div class="highlight"><pre><span></span><code>// 我们需要一个类型来表示元组
class HWTuple2[A &lt;: Data, B &lt;: Data](val _1: A, val _2: B) extends Bundle

// 提供一个 Tuple 和 HWTuple 之间的 DataView
implicit def view[A &lt;: Data, B &lt;: Data]: DataView[(A, B), HWTuple2[A, B]] =
  DataView(tup =&gt; new HWTuple(tup._1.cloneType, tup._2.cloneType),
           _._1 -&gt; _._1, _._2 -&gt; _._2)
</code></pre></div>
<p>现在，我们可以使用 <code>.viewAs</code> 像他们是 <code>Data</code> 的子类型一样来查看元组：</p>
<div class="highlight"><pre><span></span><code>class TupleVerboseExample extends RawModule {
  val a, b, c, d = IO(Input(UInt(8.W)))
  val cond = IO(Input(Bool()))
  val x, y = IO(Output(UInt(8.W)))
  (x, y).viewAs[HWTuple[UInt, UInt]] := Mux(cond, (a, b).viewAs[HWTuple2[UInt, UInt]], (c, d).viewAs[HWTuple2[UInt, UInt]])
}
</code></pre></div>
<p>这比直接使用元组的原始想法要冗长得多。我们可以通过提供将 <code>Tuple</code> 视为 <code>HWTuple2</code> 的隐式转换来改善这一点：</p>
<div class="highlight"><pre><span></span><code>implicit def tuple2hwtuple[A &lt;: Data, B &lt;: Data](tup: (A, B)): HWTuple2[A, B] = 
  tup.viewAs[HWTuple(A, B)]
</code></pre></div>
<p>现在，原始的代码就可以运行了！</p>
<div class="highlight"><pre><span></span><code>class TupleExample extends RawModule {
  val a, b, c, d = IO(Input(UInt(8.W)))
  val cond = IO(Input(Bool()))
  val x, y = IO(Output(UInt(8.W)))
  (x, y) := Mux(cond, (a, b), (c, d))
}
</code></pre></div>
<p>注意这个示例忽略了另一个必须的部分，<code>DataProduct</code>（查看下面的相关文档）</p>
<p>所有的这些都可以通过一次导入启用：</p>
<div class="highlight"><pre><span></span><code>import chisel3.experiment.conversions._
</code></pre></div>
<h2 id="dataview_1">完全的和部分的 DataView<a class="headerlink" href="#dataview_1" title="Permanent link">&para;</a></h2>
<p>当目标类型和 View 类型的所有字段都包含在映射中时，<code>DataView</code> 是完整的。如果 <code>DataView</code> 中有的字段被遗忘了 Chisel 就会报错。如下所示：</p>
<div class="highlight"><pre><span></span><code>class BundleA extends Bundle {
  val foo = UInt(8.W)
  val bar = UInt(8.W)
}
class BundleB extends Bundle {
  val fizz = UInt(8.W)
}
// 我们在映射中忘记了 foo
implicit val myView = DataView[BundleA, BundleB](_ =&gt; new BundleB, _.bar -&gt; _.fizz)
class BadMapping extends Module {
  val in = IO(Input(new BundleA))
  val out = IO(Output(new BundleB))
  out := in.viewAs[BundleB]
}
// 我们需要运行 Chisel 来看到错误
getVerilogString(new BadMapping)
// chisel3.experimental.dataview.package$InvalidViewException: Viewing BadMapping.in: IO[BundleA] as BundleB is non-Total!
//   Target field &#39;_.foo&#39; is missing.
//   DataView used is DataView(defined @[dataview.md 228:49]).
//   If the view *should* be non-total, try a &#39;PartialDataView&#39;.
//  at ... ()
//  at repl.MdocSession$MdocApp6$$anonfun$55$BadMapping$1$$anonfun$60.apply(dataview.md:232)
//  at repl.MdocSession$MdocApp6$$anonfun$55$BadMapping$1$$anonfun$60.apply(dataview.md:232)
//  at chisel3.Data.$anonfun$$colon$eq$1(Data.scala:681)
//  at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
//  at chisel3.experimental.prefix$.apply(prefix.scala:33)
//  at chisel3.Data.$colon$eq(Data.scala:681)
//  at repl.MdocSession$MdocApp6$$anonfun$55$BadMapping$1.&lt;init&gt;(dataview.md:232)
//  at repl.MdocSession$MdocApp6$$anonfun$55$$anonfun$apply$67.apply(dataview.md:234)
//  at repl.MdocSession$MdocApp6$$anonfun$55$$anonfun$apply$67.apply(dataview.md:234)
//  at ... ()
//  at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace)
</code></pre></div>
<p>就像报错中建议的，如果我们希望 view 是不完全的，我们可以使用 <code>PartialDataView</code>：</p>
<div class="highlight"><pre><span></span><code>// PartialDataView 不用是目标的全部
implicit val myView = PartialDataView[BundleA, BundleB](_ =&gt; new BundleB, _.bar -&gt; _.fizz)
class PartialDataViewModule extends Module {
  val in = IO(Input(new BundleA))
  val out = IO(Output(new BundleB))
  out = in.viewAs[BundleB]
}
// Generated by CIRCT firtool-1.44.0
module PartialDataViewModule(   // &lt;stdin&gt;:3:10
  input        clock,   // &lt;stdin&gt;:4:11
               reset,   // &lt;stdin&gt;:5:11
  input  [7:0] in_foo,  // dataview.md:247:15
               in_bar,  // dataview.md:247:15
  output [7:0] out_fizz // dataview.md:248:16
);

  assign out_fizz = in_bar; // &lt;stdin&gt;:3:10
endmodule
</code></pre></div>
<p>虽然 <code>PartialDataView</code> 不需要是*目标类型*的全部，但是*View 类型*的 <code>PartialDataView</code> 和 <code>DataView</code> 必须是全部。这导致 <code>PartialDataView</code> **不能**像 <code>DataView</code> 那样可逆。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code>implicit val myView2 = myView.invert(_ =&gt; new BundleA)
class PartialDataViewModule2 extends Module {
  val in = IO(Input(new BundleA))
  val out = IO(Output(new BundleB))
  // 使用逆转后的映射
  out.viewAs[BundleA] := in
}
// 我们要运行 Chisel 得到报错
getVerilogString(new PartialDataViewModule2)
// chisel3.experimental.dataview.package$InvalidViewException: Cannot invert &#39;PartialDataView(defined @[dataview.md 243:56])&#39; as it is non-total.
//   Try providing a DataView[MdocApp6.this.BundleB, MdocApp6.this.BundleA].
//   Please see https://www.chisel-lang.org/chisel3/docs/explanations/dataview.
//  at chisel3.experimental.dataview.DataView$InvertibleDataView.invert(DataView.scala:138)
//  at repl.MdocSession$MdocApp6$$anonfun$67.apply(dataview.md:263)
//  at repl.MdocSession$MdocApp6$$anonfun$67.apply(dataview.md:262)
</code></pre></div>
<p>就像提到的那样，映射必须是 <code>View</code> 的全部。</p>
<h2 id="_10">进阶细节<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h2>
<p><code>DataView</code> 利用了很多 Chisel 用户可能不熟悉的 scala 功能，特别是 Type 类。</p>
<h3 id="type">Type 类<a class="headerlink" href="#type" title="Permanent link">&para;</a></h3>
<p>Type 类是用于编写多态代码的强大语言功能。它们是 Scala、Swift（参见 <a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/protocols">Protocols</a>）和 Rust（参见 <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">Traits</a>）等“现代编程语言”的常见功能。Type 类可能看起来类似于面向对象编程中的继承，但有一些重要的区别：</p>
<ol>
<li>你可以为不属于你的类型提供 Type 类（例如，在第三方库、Scala 标准库或 Chisel 本身中定义的类型）</li>
<li>你可以为许多没有子类型关系的类型编写单个 Type 类</li>
<li>你可以为同一类型提供多个不同的 Type 类</li>
<li>对于 <code>DataView</code>，1 至关重要，因为我们希望能够实现内置 Scala 类型（如元组和 <code>Seq</code>）的 DataView。此外，<code>DataView</code> 有两个类型参数（<em>Target</em> 和 <em>View 类型</em>），因此继承实际上没有意义 —— 哪种类型可以扩展 DataView？</li>
</ol>
<p>在 Scala2 中，Type 类不是一个内置的语言特性，而是使用 implicit 实现。若有兴趣可以阅读：</p>
<ul>
<li><a href="https://scalac.io/blog/typeclasses-in-scala">基础教程</a></li>
<li><a href="https://stackoverflow.com/questions/5598085/where-does-scala-look-for-implicits/5598107">在 StackOverflow 上很有意义的解释</a></li>
</ul>
<p>请注意，Scala 3 添加了不适用于 Chisel 3 的 Type 类内置语法，Chisel 3 目前仅支持 Scala 2。</p>
<h3 id="implicit">implicit 解析<a class="headerlink" href="#implicit" title="Permanent link">&para;</a></h3>
<p>鉴于 <code>DataView</code> 是使用 implicit 实现的，理解 implicit 就很重要。当编译器需要隐式参数时，它首先在*当前作用域*寻找，然后才在隐式作用域寻找。</p>
<ol>
<li>当前作用域</li>
<li>当前作用域定义的值</li>
<li>显式导入</li>
<li>通配符导入</li>
<li>隐式作用域</li>
<li>类型的伴生对象</li>
<li>参数类型的隐式范围</li>
<li>类型参数的隐式范围</li>
</ol>
<p>如果在任一阶段发现多个 implicit，则使用静态重载规则来解决它。简而言之，如果一种 implicit 用于另一种更具体的类型，则将选择更具体的类型。如果在给定阶段内应用多个 implicit，则编译器会抛出不明确的 implicit 解析错误。</p>
<p>本节大量借鉴了 <a href="https://stackoverflow.com/questions/5598085/where-does-scala-look-for-implicits/5598107">1</a> 和 <a href="https://stackoverflow.com/questions/8623055/scala-implicit-parameter-resolution-precedence/8694558">2</a>。尤其是查看 [1] 的示例</p>
<h4 id="implicit_1">implicit 解析示例<a class="headerlink" href="#implicit_1" title="Permanent link">&para;</a></h4>
<p>为了更加清楚的理解，我们考虑一下 implicit 解析是如何为 <code>DataView</code> 工作的。看 <code>viewAs</code> 的定义：</p>
<div class="highlight"><pre><span></span><code>def viewAs[V &lt;: Data](implicit dataView: DataView[T, V]): V
</code></pre></div>
<p>有了上一节的知识，我们知道每当我们调用 <code>.viewAs</code> 时，Scala 编译器将首先在当前作用域（定义或导入）中查找 <code>DataView[T, V]</code>，然后查找 <code>DataView</code>、<code>T</code> 和 <code>V</code> 的伴生对象。这实现了一种相当强大的模式，即 <code>DataView</code> 的默认或典型实现应该在两种类型之一的伴生对象中定义。我们可以将这种方式定义的 <code>DataView</code> 视为“低优先级默认值”。如果给定用户想要不同的行为，那么它们可以被特定的导入否决。例如：</p>
<p>给定以下类型：</p>
<div class="highlight"><pre><span></span><code>class Foo extends Bundle {
  val a = UInt(8.W)
  val b = UInt(8.W)
}

class Bar extends Bundle {
  val c = UInt(8.W)
  val d = UInt(8.W)
}

object Foo {
  implicit val f2b = DataView[Foo, Bar](_ =&gt; new Bar, _.a -&gt; _.c, _.b -&gt; _.d)
  implicit val b2f = f2b.invert(_ =&gt; new Foo)
}
</code></pre></div>
<p>这在隐式作用域中提供了 DataView 的实现，作为 Foo 和 Bar 之间的“默认”映射（甚至不需要导入！）：</p>
<div class="highlight"><pre><span></span><code>class FooToBar extends Module {
  val foo = IO(Input(new Foo))
  val bar = IO(Output(new Bar))
  bar := foo.viewAs[Bar]
}
// Generated by CIRCT firtool-1.44.0
module FooToBar(    // &lt;stdin&gt;:3:10
  input        clock,   // &lt;stdin&gt;:4:11
               reset,   // &lt;stdin&gt;:5:11
  input  [7:0] foo_a,   // dataview.md:301:15
               foo_b,   // dataview.md:301:15
  output [7:0] bar_c,   // dataview.md:302:15
               bar_d    // dataview.md:302:15
);

  assign bar_c = foo_a; // &lt;stdin&gt;:3:10
  assign bar_d = foo_b; // &lt;stdin&gt;:3:10
endmodule
</code></pre></div>
<p>然而，一些 <code>Foo</code> 和 <code>Bar</code> 的用户可能希望有不同的行为，也许相对于直接映射他们更喜欢 “Swizzling” 的行为：</p>
<div class="highlight"><pre><span></span><code>object Swizzle {
  implicit val swizzle = DataView[Foo, Bar](_ =&gt; new Bar, _.a -&gt; _.d, _.b -&gt; _.c)
}
// 当前作用域永远胜过隐式作用域
import Swizzle._
class FooToBarSwizzled extends Module {
  val foo = IO(Input(new Foo))
  val bar = IO(Output(new Bar))
  bar := foo.viewAs[Bar]
}
// Generated by CIRCT firtool-1.44.0
module FooToBarSwizzled(    // &lt;stdin&gt;:3:10
  input        clock,   // &lt;stdin&gt;:4:11
               reset,   // &lt;stdin&gt;:5:11
  input  [7:0] foo_a,   // dataview.md:325:15
               foo_b,   // dataview.md:325:15
  output [7:0] bar_c,   // dataview.md:326:15
               bar_d    // dataview.md:326:15
);

  assign bar_c = foo_b; // &lt;stdin&gt;:3:10
  assign bar_d = foo_a; // &lt;stdin&gt;:3:10
endmodule
</code></pre></div>
<h2 id="dataproduct">DataProduct<a class="headerlink" href="#dataproduct" title="Permanent link">&para;</a></h2>
<p><code>DataProduct</code> 是 <code>DataView</code> 用于验证用户提供的映射的正确性的 Type 类。为了使类型可查看（即 <code>DataView</code> 的 <code>Target</code> 类型），它必须具有 <code>DataProduct</code> 的实现。</p>
<p>例如，假设我们有一些 non-Bundle 类型：</p>
<div class="highlight"><pre><span></span><code>// 基于 chisel3.util.Counter
class MyCounter(val width: Int) {
  /** 指示计数器是否在本周期递增 */
  val active = WireDefault(false.B)
  val value = RegInit(0.U(width.W))
  def inc(): Unit = {
    active := true.B
    value := value + 1.U
  }
  def reset(): Unit = {
    value := 0.U
  }
}
</code></pre></div>
<p>假设我们要将 <code>MyCounter</code> 视为 <code>Valid[UInt]</code>：</p>
<div class="highlight"><pre><span></span><code>import chisel3.util.Valid
implicit val counterView = DataView[MyCounter, Valid[UInt]](c =&gt; Valid(UInt(c.width.W)), _.value -&gt; _.bits, _.active -&gt; _.valid)
// error: myView is already defined as value myView
// implicit val myView = PartialDataView[BundleA, BundleB](_ =&gt; new BundleB, _.bar -&gt; _.fizz)
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// error: Could not find implicit value for DataView[MdocApp1.this.BundleA, MdocApp1.this.BundleB].
// Please see https://www.chisel-lang.org/chisel3/docs/explanations/dataview
//    out := in.viewAs[BundleB]
//           ^^^^^^^^^^^^^^^^^^
// error: Could not find implicit value for DataView[MdocApp1.this.BundleA, MdocApp1.this.BundleB].
// Please see https://www.chisel-lang.org/chisel3/docs/explanations/dataview
//    out := in.viewAs[BundleB]
//           ^^^^^^^^^^^^^^^^^^
// error: Could not find implicit value for DataView[MdocApp1.this.BundleB, MdocApp1.this.BundleA].
// Please see https://www.chisel-lang.org/chisel3/docs/explanations/dataview
//    out.viewAs[BundleA] := in
//    ^^^^^^^^^^^^^^^^^^^
// error: Could not find implicit value for DataProduct[MdocApp1.this.MyCounter].
// Please see https://www.chisel-lang.org/chisel3/docs/explanations/dataview#dataproduct
// implicit val counterView = DataView[MyCounter, Valid[UInt]](c =&gt; Valid(UInt(c.width.W)), _.value -&gt; _.bits, _.active -&gt; _.valid)
//                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre></div>
<p>如你所见，Scala 会编译失败，我们需要提供 <code>DataProductp[Mycounter]</code> 的实现，它为 Chisel 提供了一种访问 <code>MyCounter</code> 中 <code>Data</code> 类型的对象的方法：</p>
<div class="highlight"><pre><span></span><code>import chisel3.util.Valid
implicit val counterProduct = new DataProduct[MyCounter] {
  // 元组的字符串部分时对象的字符串路径，用来帮助调试
  def dataIterator(a: MyCounter, path: String): Iterator[(Data, String)] =
    List(a.value -&gt; s&quot;$path.value&quot;, a.active -&gt; s&quot;$path.active&quot;).iterator
}
// Now this works
implicit val counterView = DataView[MyCounter, Valid[UInt]](c =&gt; Valid(UInt(c.width.W)), _.value -&gt; _.bits, _.active -&gt; _.valid)
</code></pre></div>
<p>为什么这有用？这就是 Chisel 能够检查 <code>DataView</code> 完整性的方式。除了检查用户是否在映射之外遗漏了字段之外，它还允许 Chisel 检查用户是否在映射中包含了实际上不属于*目标*或 *view 类型*部分的 <code>Data</code>。</p>
<h1 id="function-module-creation">功能模块创建（Function Module Creation）<a class="headerlink" href="#function-module-creation" title="Permanent link">&para;</a></h1>
<p>Scala 中的对象有一个预先存在的创建函数（方法），叫 <code>apply</code>。当一个对象在表达式中被用作值时（这一般意味着调用了构造函数），这个方法确认了返回值。当处理硬件模块时，人们会希望模块的输出能够代表模块的功能。因此，我们有时会希望对象在表达式中被用作值时的返回值是模块的输出。因为硬件模块被表达为 Scala 对象，所以我们可以定义对象的 <code>apply</code> 方法使其返回模块的输出。这可以被称作为模块的构造创建函数接口。如果我们将其用于标准的 mux2 示例，我们要在表达式中使用 mux2 时返回 mux2 的输出。实现这一功能需要建立使用多路选择器输入作为参数，返回多路选择器输出的构造函数：</p>
<div class="highlight"><pre><span></span><code>import chisel3._

class Mux2 extends Module {
  val io = IO(new Bundle {
    val sel = Input(Bool())
    val in0 = Input(UInt())
    val in1 = Input(UInt())
    val out = Output(UInt())
  })
  io.out := Mux(io.sel, io.in0, io.in1)
}

object Mux2 {
  def apply(sel: UInt, in0: UInt, in1: UInt) = {
    val m = Module(new Mux2)
    m.io.in0 := in0
    m.io.in1 := in1
    m.io.sel := sel
    m.io.out
  }
}
</code></pre></div>
<p>就如我们在代码示例中看到的一样，我们定义了 <code>apply</code> 方法来将 Mux2 的输入作为参数，并将 Mux2 的输出作为幻术的返回值。通过这样定义模块，使得之后实现这一常用模块的更大更复杂的版本变得简单。例如，我们之前是这样实现 Mux4 的：</p>
<div class="highlight"><pre><span></span><code>class Mux4 extends Module {
  val io = IO(new Bundle) {
    val in0 = Input(UInt(1.W))
    val in1 = Input(UInt(1.W))
    val in2 = Input(UInt(1.W))
    val in3 = Input(UInt(1.W))
    val sel = Input(UInt(2.W))
    val out = Input(UInt(1.W))
  }
  val m0 = Module(new Mux2)
  m0.io.in0 := io.in0
  m0.io.in1 := io.in1
  mo.io.sel := io.sel(0)

  val m1 = Module(new Mux2)
  m1.io.in0 := io.in2
  m1.io.in1 := io.in3
  m1.io.sel := io.sel(0)

  val m3 Module(new Mux2)
  m3.io.in0 := m0.io.out
  m3.io.in1 := m1.io.out
  m3.io.sel := io.sel(1)

  io.out := m3.io.out
}
</code></pre></div>
<p>然而，使用我们为 Mux2 重定义的创建函数，现在在编写 Mux4 输出表达的时候就可以将 Mux2 的输出当作模块自身的值使用了：</p>
<div class="highlight"><pre><span></span><code>class Mux4 extends Module {
  val io = IO(new Bundle {
    val in0 = Input(UInt(1.W))
    val in1 = Input(UInt(1.W))
    val in2 = Input(UInt(1.W))
    val in3 = Input(UInt(1.W))
    val sel = Input(UInt(2.W))
    val out = Input(UInt(1.W))
  })

  io.out := Mux2(io.sel(1), 
                 Mux2(io.sel(0), io.in0, io.in1),
                 Mun2(io.sel(0), io.in0, io.in1))
}
</code></pre></div>
<p>这使得我们能够编写更直观可读的硬件连接描述，这类似于软件表达式。</p>
<h1 id="muxes-and-input-selection">多路复用器和输入选择（Muxes and Input Selection）<a class="headerlink" href="#muxes-and-input-selection" title="Permanent link">&para;</a></h1>
<p>在硬件描述中选择输入非常重要，因此 Chisel 提供了一些内置的通用输入选择的实现。</p>
<h2 id="mux">Mux<a class="headerlink" href="#mux" title="Permanent link">&para;</a></h2>
<p>第一个是 <code>Mux</code>。这是一个 2 输入选择器。与之前展示的 <code>Mux2</code> 示例不同，内置的 <code>Mux</code> 允许输入（<code>in0</code> 和 <code>in1</code>）是任何数据类型，只要他们都是 <code>Data</code> 的子类。</p>
<p>通过使用上一节提到的函数模型创建的特性，我们可以简单的创建一个多输入选择器：</p>
<div class="highlight"><pre><span></span><code>Mux(c1, a, Mux(c2, b, Mux(..., default)))
</code></pre></div>
<h2 id="muxcase">MuxCase<a class="headerlink" href="#muxcase" title="Permanent link">&para;</a></h2>
<p>嵌套的 <code>Mux</code> 不是必须的，因为 Chisel 提供了内置的 <code>MuxCase</code>，它实现了这个功能。<code>MuxCase</code> 是一个 n 路 <code>Mux</code>，使用示例如下：</p>
<div class="highlight"><pre><span></span><code>MuxCase(default, Array(c1 -&gt; a, c2 -&gt; b, ...))
</code></pre></div>
<p>其中每一个选择依赖项都表示为 Scala 元组 [condition -&gt; selected_input_port]</p>
<h2 id="muxlookup">MuxLookup<a class="headerlink" href="#muxlookup" title="Permanent link">&para;</a></h2>
<p>Chisel 也提供了 <code>MuxLookup</code>，它是一个 n 路可索引多路选择器：</p>
<div class="highlight"><pre><span></span><code>MuxLookup(idx, default)(Array(0.U -&gt; a, 1.U -&gt; b, ...))
</code></pre></div>
<p>这和条件是基于索引的 <code>MuxCase</code> 作用相同：</p>
<div class="highlight"><pre><span></span><code>MuxCase(default,
        Array((idx === 0.U) -&gt; a),
              (idx === 1.U) -&gt; b, ...)
</code></pre></div>
<p>注意条件/情况/选择信号（即 c1, c2）都要在括号里。</p>
<h2 id="mux1h">Mux1H<a class="headerlink" href="#mux1h" title="Permanent link">&para;</a></h2>
<p>另一种 <code>Mux</code> 是独热多路复用器，<code>Mux1H</code>。它使用一系列选择信号和值，并返回与置位的选择信号关联的值。没有置位的选择信号和多个置位的选择信号是未定义的行为。举个例子：</p>
<div class="highlight"><pre><span></span><code>val hostvalue = chisel3.util.Mux1H(seq(
  io.selector(0) -&gt; 2.U,
  io.selector(1) -&gt; 4.U,
  io.selector(2) -&gt; 8.U,
  io.selector(4) -&gt; 11.U,
))
</code></pre></div>
<p><code>Mux1H</code> 只要有可能就会生成很容易优化为低深度与/或树的 Firrtl。这一优化在值的类型为 <code>FixedPoint</code> 或一个包含 <code>FixedPoint</code> 的聚合类型时不可用，并且结果会使用一个简单的 <code>Mux</code> 树替代。这个行为不一定是最佳的。由于 <code>FixedPoint</code> 仍处于*实验阶段*，这一行为未来可能会有变化。</p>
<h1 id="multiple-clock-domains">多时钟域（Multiple Clock Domains）<a class="headerlink" href="#multiple-clock-domains" title="Permanent link">&para;</a></h1>
<p>Chisel 3 支持多时钟域。</p>
<p>注意，为了安全的跨时钟域，你需要适当的同步逻辑（比如异步 FIFO）。你可以使用 <a href="https://github.com/ucb-bar/asyncqueue">AsyncQueue 库</a>轻松的做到这一点。</p>
<div class="highlight"><pre><span></span><code>import chisel3._

class MultiClockModule extends Module {
  val io = IO(new Bundle {
    val clockB = Input(Clock())
    val resetB = Input(Bool())
    val stuff = Input(Bool())
  })

  // 该寄存器时钟使用模块时钟
  val regClock = RegNext(io.stuff)

  withClockAndReset (io.clockB, io.resetB) {
    // 在这个 withClock 中，所有的同步元素都依靠 io.clockB 作为时钟。
    // 这个区域中触发器的复位使用的是显式提供的复位 io.resetB。

    // 该寄存器使用 io.ClockB 作为时钟
    val regClockB = RegNext(io.stuff)
  }

  // 该寄存器也使用模块时钟作为时钟
  val regClock2 = RegNext(io.stuff)
}
</code></pre></div>
<p>你也可以在其他时钟域中实例化模块：</p>
<div class="highlight"><pre><span></span><code>import chisel3._

class ChildModule extends Module {
  val io = IO(new Bundle {
    val in = Input(Bool())
  })
}

class MultiClockModule extends Module {
  val io = IO(new Bundle {
    val clockB = Input(Clock())
    val resetB = Input(Bool())
    val stuff = Input(Bool())
  })

  val clockB_child = withClockAndReset (io.clockB, io.ResetB) { Module(new ChildModule) }
  clockB_child.io.in := io.stuff
}
</code></pre></div>
<p>如果你只希望将你的时钟连接到新的时钟域，使用常用的隐式复位信号，你可以使用 <code>withClock(clock)</code> 替换 <code>withClockAndReset</code>。</p>
<div class="highlight"><pre><span></span><code>import chisel3._

class MultiClockModule extends Module {
  val io = IO(new Bundle {
    val clockB = Input(Clock())
    val stuff = Input(Bool())
  })

  // 该寄存器时钟使用模块时钟
  val regClock = RegNext(io.stuff)

  withClock (io.clockB) {
    // 在这个 withClock 中，所有的同步元素都依靠 io.clockB 作为时钟。

    // 该寄存器使用 io.ClockB 作为时钟
    val regClockB = RegNext(io.stuff)
  }

  // 该寄存器也使用模块时钟作为时钟
  val regClock2 = RegNext(io.stuff)
}

  // 使用隐式复位实例化其他时钟域的模块
class MultiClockModule2 extends Module {
  val io = IO(new Bundle {
    val clockB = Input(Clock())
    val stuff = Input(Bool())
  })

  val clockB_chikd = withClock (io.clockB) { Module(new ChildModule) }
  clockB_child.io.in := io.stuff
}

class ChildModule extends Module {
  val io = IO(new Bundle{
    val in = Input(Bool())
  })
}
</code></pre></div>
<h1 id="reset">复位（Reset）<a class="headerlink" href="#reset" title="Permanent link">&para;</a></h1>
<p>从 chisel 3.2.0 开始，Chisel 3 支持同步和异步复位，这意味着它可以原生支持同步复位寄存器和异步复位寄存器。</p>
<p>寄存器的类型基于关联至其的复位信号的类型。</p>
<p>有三种类型的复位实现了公共特征 <code>Reset</code>：</p>
<ul>
<li><code>Bool</code> —— 用 <code>Bool()</code> 构造，也称“同步复位”。</li>
<li><code>AsyncReset</code> —— 用 <code>AsyncReset()</code> 构造，也称“异步复位”。</li>
<li><code>Reset</code> —— 用 <code>Reset()</code> 构造，也称为“抽象复位”。</li>
</ul>
<p>出于实现原因，具体的 Scala 类型是 <code>ResetType</code>。从风格上讲，我们避免使用 <code>ResetType</code>，而是使用公共特征 <code>Reset</code>。</p>
<p>使用 <code>Bool()</code> 类型的复位信号的寄存器会作为同步复位触发器，使用 <code>AsyncReset</code> 类型复位信号的寄存器作为异步复位寄存器，使用 <code>Reset</code> 类型复位信号的寄存器将在 FIRRTL 编译期间*推断*它的类型。</p>
<h2 id="_11">复位推断<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h2>
<p>FIRRTL 将为有抽象 <code>Reset</code> 类型的信号推断一个具体类型，规则如下：</p>
<ol>
<li>在其扇入扇出中只有 <code>AsyncReset</code> 类型，抽象 <code>Reset</code> 类型和 <code>Dontcare</code> 类型，推断为 <code>AsyncReset</code>。</li>
<li>在其扇入扇出中有 <code>Bool</code> 类型和 <code>AsyncReset</code> 类型是错误的。</li>
<li>其他情况下将被推断为 <code>Bool</code> 类型。</li>
</ol>
<p>你可以将第 3 条视为第 1 条用 <code>Bool</code> 替换 <code>AsyncReset</code> 的版本，并附加一条，即扇入扇出中既没有 <code>AsyncReset</code> 也没有 <code>Bool</code> 类型的抽象复位将被默认为 <code>Bool</code> 类型。这种“默认”情况并不常见，因为它意味着复位信号由 <code>Dontcare</code> 驱动。</p>
<h2 id="_12">隐式复位<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h2>
<p>一个 <code>Module</code> 的 <code>reset</code> 是一个抽象 <code>Reset</code>。为了向后兼容，如果顶层模块有隐式复位，将默认为 <code>Bool</code> 类型。</p>
<h3 id="_13">设置隐式复位类型<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h3>
<p><em>Chisel 3.3.0 的新特性</em></p>
<p>如果你想在模块（包括顶级模块）内设置重置类型，而不是依赖重置推理，可以加入以下特征之一：</p>
<ul>
<li><code>RequireSyncReset</code> —— 将 <code>reset</code> 的类型设置为 <code>Bool</code></li>
<li><code>RequireAsyncReset</code> —— 将 <code>reset</code> 的类型设置为 <code>AsyncReset</code></li>
</ul>
<p>比如：</p>
<div class="highlight"><pre><span></span><code>class MyAlwaysSyncResetModule extends Module with RequireSyncReset {
  val mySyncResetReg = RegInit(false.B) // 复位是 Bool 类型的
}
class MyAlwaysAsyncResetModule extends Module with RequireAsyncReset {
  val myAsyncResetReg = RegInit(false.B) // 复位是 AsyncReset 类型的
}
</code></pre></div>
<p>**注意：**这会设置具体类型，但 Scala 类型将保持 <code>Reset</code>，因此类型转换仍然是有必要的。这一问题通常出现于在逻辑中使用 <code>Bool</code> 类型复位的时候。</p>
<h2 id="reset-agnostic-code">与复位无关的代码（Reset-Agnostic Code）<a class="headerlink" href="#reset-agnostic-code" title="Permanent link">&para;</a></h2>
<p>抽象复位的目的是使设计与所使用的复位规则无关的硬件成为可能。这使得重置规则与模块的功能无关的实用程序和设计可以重用代码。</p>
<p>考虑下面的两个示例模块，它们与其中使用的重置类型无关：</p>
<div class="highlight"><pre><span></span><code>class ResetAgnosticModule extends Module {
  val io = IO(new Bundle {
    val out = UInt(4.W)
  })
  val resetAgnosticReg = RegInit(0.U(4.W))
  resetAgnosticReg := resetAgnosticReg + 1.U
  io.out := resetAgnosticReg
}

class ResetAgnosticRawModule extends RawModule {
  val clk = IO(Input(Clock()))
  val rst = IO(Input(Reset()))
  val out = IO(Output(UInt(8.W)))

  val resetAgnosticReg = withClockAndReset(clk, rst)(RegInit(0.U(8.W)))
  resetAgnosticReg := resetAgnosticReg + 1.U
  out := resetAgnosticReg
}
</code></pre></div>
<p>这些模块可用于同步和异步复位域。它们的重置类型将根据使用它们的上下文来推断。</p>
<h2 id="forcing-reset-type">强制复位类型（Forcing Reset Type）<a class="headerlink" href="#forcing-reset-type" title="Permanent link">&para;</a></h2>
<p>你可以如上所述设置模块隐式复位的类型。</p>
<p>你也可以强制执行具体类型的复位。</p>
<ul>
<li><code>.asBool</code> 会将 <code>Reset</code> 重新解释为 <code>Bool</code></li>
<li><code>.asAsyncReset</code> 将重置重新解释为 <code>AsyncReset</code>。</li>
</ul>
<p>然后，您可以使用 <code>withReset</code> 将强制转换复位用作隐式重置。有关 <code>withReset</code> 的更多信息，请参阅多时钟域。</p>
<p>以下将使 <code>myReg</code> 以及两个 <code>ResetAgnosticRegs</code> 同步复位：</p>
<div class="highlight"><pre><span></span><code>class ForcedSyncReset extends Module {
  // withReset 的 参数作为这个作用域中的隐式复位参数
  withReset (reset.asBool) {
    val myReg = RegInit(0.U)
    val myModule = Module(new ResetAgnosticModule)

    // RawModules 没有隐式复位所以 withReset 没有影响
    val myRawModule = Module(new ResetAgnosticRawModule)
    // 我们必须手动驱动复位端口
    myRawModule.rst := Module.reset // Module.reset 获取当前的隐式复位
  }
}
</code></pre></div>
<p>以下将使 <code>myReg</code> 以及 <code>ResetAgnosticRegs</code> 异步重置：</p>
<div class="highlight"><pre><span></span><code>class ForcedAysncReset extends Module {
  // withReset 的 参数作为这个作用域中的隐式复位参数
  withReset (reset.asAsyncReset){
    val myReg = RegInit(0.U)
    val myModule = Module(new ResetAgnosticModule) // myModule.reset 被隐式连接了

    // RawModules 没有隐式复位所以 withReset 没有影响
    val myRawModule = Module(new ResetAgnosticRawModule)
    // 我们必须手动驱动复位端口
    myRawModule.rst := Module.reset // Module.reset 获取当前的隐式复位
  }
}
</code></pre></div>
<p>**注意：**FIRRTL 不会检查此类转换（<code>asBool</code> 和 <code>asAsyncReset</code>）。在进行这样的强制转换时，作为设计者，实际上是在告诉编译器你知道自己在做什么，并强制类型进行强制转换。</p>
<h2 id="last-connect-semantics">最后连接语义（Last-Connect Semantics）<a class="headerlink" href="#last-connect-semantics" title="Permanent link">&para;</a></h2>
<p>使用最后连接语义覆盖重置类型是不合法的，除非您要覆盖 <code>DontCare</code>：</p>
<div class="highlight"><pre><span></span><code>class MyModule extends Module {
  val resetBool = Wire(Reset())
  resetBool := DontCare
  resetBool := false.B // 这是正确的
  withReset(resetBool) {
    val mySubmodule = Module(new Submodule())
  }
  resetBool := true.B // 这是正确的
  resetBool := false.B.asAsyncReset // 在 FIRRTL 中这是错误的
}
</code></pre></div>
<h1 id="polymorphism-and-parameterization">多态与参数化（Polymorphism and Parameterization）<a class="headerlink" href="#polymorphism-and-parameterization" title="Permanent link">&para;</a></h1>
<p><em>这一节是进阶部分，第一次阅读可以掠过。</em></p>
<p>Scala 是一种强类型语言，使用参数化类型来指定函数和类。在本节中，我们将展示 Chisel 用户如何使用参数化类定义自己的可重用函数和类。</p>
<h2 id="_14">参数化函数<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h2>
<p>之前我们在 <code>Bool</code> 上定义了 <code>Mux2</code>，但现在我们展示如何定义通用多路复用器函数。我们将此函数定义为采用布尔条件以及 <code>T</code> 类型的 con 和 alt 参数（对应于 then 和 else 表达式）：</p>
<div class="highlight"><pre><span></span><code>def Mux[T &lt;: Bits](c: Bool, con: T, alt: T): T = (...)
</code></pre></div>
<p>其中 <code>T</code> 必须是 <code>Bits</code> 的子类。 Scala 确保在 <code>Mux</code> 的每次使用中，它都能找到实际 con 和 alt 参数类型的公共超类，否则会导致 Scala 编译类型错误。例如，</p>
<div class="highlight"><pre><span></span><code>Mux(c, UInt(10), UInt(11))
</code></pre></div>
<p>这会产生一个 <code>UInt</code> 线，因为 con 和 alt 参数都是 <code>UInt</code> 类型。</p>
<h2 id="_15">参数化类<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h2>
<p>与参数化函数一样，我们也可以参数化类以使其更具可重用性。例如，我们可以概括 Filter 类以使用任何类型的链接。我们通过参数化 <code>FilterIO</code> 类并定义构造函数以采用 <code>T</code> 类型的单个参数 <code>gen</code> 来实现此目的，如下所示。</p>
<div class="highlight"><pre><span></span><code>class FilterIO[T &lt;: Data](gen: T) extends Bundle {
  val x = Input(gen)
  val y = Output(gen)
}
</code></pre></div>
<p>现在，我们可以通过定义一个模块类来定义 <code>Filter</code>，该模块类也采用链接类型构造函数参数并将其传递给 <code>FilterIO</code> 接口构造函数：</p>
<div class="highlight"><pre><span></span><code>class Filter[T &lt;: Data](gen: T) extends Module {
  val io = IO(new FilterIO(gen))
  // ...
}
</code></pre></div>
<p>我们现在可以如下定义一个基于 <code>PLink</code> 的 <code>Filter</code>：</p>
<div class="highlight"><pre><span></span><code>val f = Module(new Filter(new PLink))
</code></pre></div>
<p>一个通用 FIFO 可以被定义为：</p>
<div class="highlight"><pre><span></span><code>import chisel3.util.log2Up

class DataBundle extends Bundle {
  val a = UInt(32.W)
  val b = UInt(32.W)
}

class Fifo[T &lt;: Data](gen: T, n: Int) extends Module {
  val io = IO(new Bundle {
    val enqVal = Input(Bool())
    val enqRdy = Output(Bool())
    val deqVal = Output(Bool())
    val deqRdy = Input(Bool())
    val enqDat = Input(gen)
    val deqDat = Output(gen)
  })
  val enqPtr     = RegInit(0.U((log2Up(n)).W))
  val deqPtr     = RegInit(0.U((log2Up(n)).W))
  val isFull     = RegInit(false.B)
  val doEnq      = io.enqRdy &amp;&amp; io.enqVal
  val doDeq      = io.deqRdy &amp;&amp; io.deqVal
  val isEmpty    = !isFull &amp;&amp; (endPtr === deqPtr)
  val deqPtrInc  = deqPtr + 1.U
  val enqPtrInc  = enqPtr + 1.U
  val isFullNext = Mux(doEnq &amp;&amp; ~doDeq &amp;&amp; (enqPtrInc === deqPtr)),
                         true.B, Mux(doDeq &amp;&amp; isFull, false.B,
                         isFull)
  enqPtr := Mux(doEnq, enqPtrInc, enqPtr)
  deqPtr := Mux(doDeq, deqPtrInc, deqPtr)
  isFUll := isFullNext
  val ram = Men(n, gen)
  when (doEnq) {
    ram(enqPtr) := io.enqDat
  }
  io.enqRdy := !isFull
  io.deqVal := !isEmpty
  ram(deqPtr) &lt;&gt; io.deqDat
}
</code></pre></div>
<p>具有 8 个 <code>DataBundle</code> 类型元素的 <code>Fifo</code> 可以实例化为：</p>
<div class="highlight"><pre><span></span><code>val fifo = Module(new Fifo(new DataBundle, 8))
</code></pre></div>
<p>还可以定义一个通用的去耦合接口（ready/valid）：</p>
<div class="highlight"><pre><span></span><code>class DecoupledIO[T &lt;: Data](data: T) extends Bundle {
  val ready = Input(Bool())
  val valid = Output(Bool())
  val bits = Output(data)
}
</code></pre></div>
<p>然后，该模板可用于将握手协议添加到任何信号集：</p>
<div class="highlight"><pre><span></span><code>class DecoupledDemo extends DecoupledIO(new DataBundle)
</code></pre></div>
<p>FIFO 接口可以简化如下：</p>
<div class="highlight"><pre><span></span><code>class Fifo[T &lt;: Data](data: T, n: Int) extends Module {
  val io = IO(new Bundle {
    val enq = Flipped(new DecoupledIO(data))
    val deq = new Decoupled(data)
  })
  // ...
}
</code></pre></div>
<h2 id="_16">基于模块的参数化<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h2>
<p>你也可以使用其他模块而不只是类型来参数化模块。下面的例子是使用另一个模块来参数化模块的例子：</p>
<div class="highlight"><pre><span></span><code>import chisel3.RawModule
import chisel3.experimental.BaseModule
import circt.stage.ChiselStage

// 由通用模块提供了一个更专用的接口
// 没有提供有关通用模块IO的编译时信息。
trait MyAdder {
  def in1: UInt
  def in2: UInt
  def out: UInt
}

class Mod1 extends RawModule with MyAdder {
  val in1 = IO(Input(UInt(8.W)))
  val in2 = IO(Input(UInt(8.W)))
  val out = IO(Output(UInt(8.W)))
  out := in1 + in2
}

class Mod2 extends RawModule with Myadder {
  val in1 = IO(Input(UInt(8.W)))
  val in2 = IO(Input(UInt(8.W)))
  val out = IO(Output(UInt(8.W)))
  out := in1 - in2
}

class X[T &lt;: BaseModule with MyAdder](genT: =&gt; T) extends Module {
  val io = IO(new Bundle {
    val in1 = Input(UInt(8.W))
    val in2 = Input(UInt(8.W))
    val out = Output(UInt(8.W))
  })

  val subModule = Module(genT)
  io.out := subModule.out
  subMod.in1 := io.in1
  subMod.in2 := io.in2
}

println(ChiselStage.emitSystemVerilog(new X(new Mod1)))
println(ChiselStage.emitSystemVerilog(new X(new Mod2)))
// Generated by CIRCT firtool-1.44.0
module Mod1(    // &lt;stdin&gt;:3:10
  input  [7:0] in1, // polymorphism-and-parameterization.md:171:17
               in2, // polymorphism-and-parameterization.md:172:17
  output [7:0] out  // polymorphism-and-parameterization.md:173:17
);

  assign out = in1 + in2;   // &lt;stdin&gt;:3:10, polymorphism-and-parameterization.md:174:16
endmodule

module X(   // &lt;stdin&gt;:12:10
  input        clock,   // &lt;stdin&gt;:13:11
               reset,   // &lt;stdin&gt;:14:11
  input  [7:0] io_in1,  // polymorphism-and-parameterization.md:187:16
               io_in2,  // polymorphism-and-parameterization.md:187:16
  output [7:0] io_out   // polymorphism-and-parameterization.md:187:16
);

  Mod1 subMod ( // polymorphism-and-parameterization.md:192:24
    .in1 (io_in1),
    .in2 (io_in2),
    .out (io_out)
  );
endmodule

// Generated by CIRCT firtool-1.44.0
module Mod2(    // &lt;stdin&gt;:3:10
  input  [7:0] in1, // polymorphism-and-parameterization.md:179:17
               in2, // polymorphism-and-parameterization.md:180:17
  output [7:0] out  // polymorphism-and-parameterization.md:181:17
);

  assign out = in1 - in2;   // &lt;stdin&gt;:3:10, polymorphism-and-parameterization.md:182:16
endmodule

module X(   // &lt;stdin&gt;:12:10
  input        clock,   // &lt;stdin&gt;:13:11
               reset,   // &lt;stdin&gt;:14:11
  input  [7:0] io_in1,  // polymorphism-and-parameterization.md:187:16
               io_in2,  // polymorphism-and-parameterization.md:187:16
  output [7:0] io_out   // polymorphism-and-parameterization.md:187:16
);

  Mod2 subMod ( // polymorphism-and-parameterization.md:192:24
    .in1 (io_in1),
    .in2 (io_in2),
    .out (io_out)
  );
endmodule
</code></pre></div>
<h1 id="chisel-printing-in-chisel">在 Chisel 中打印（Printing in Chisel）<a class="headerlink" href="#chisel-printing-in-chisel" title="Permanent link">&para;</a></h1>
<p>Chisel 为了调试需求提供了 <code>print_f</code>。它有两种样式：</p>
<ul>
<li>Scala 风格</li>
<li>C 风格</li>
</ul>
<h2 id="scala">Scala 风格<a class="headerlink" href="#scala" title="Permanent link">&para;</a></h2>
<p>Chisel 支持 printf，其风格类似于 Scala 的 String Interpolation。Chisel 提供了一个自定义字符串插值器 cf，它遵循 C 样式格式说明符（请参阅下面的 C 风格一节）。</p>
<p>注意，在 Chisel 构造中不支持 Scalas-interpolator，它会抛出一个错误：</p>
<div class="highlight"><pre><span></span><code>class MyModule extends Module {
  val io = IO(Input(UInt(8.W)))
  printf(s&quot;in - $in\n&quot;)
}
// error: The s-interpolator prints the Scala .toString of Data objects rather than the value of the hardware wire during simulation. Use the cf-interpolator instead. If you want an elaboration time print, use println.
//   printf(s&quot;in = $in\n&quot;)
//   ^^^^^^^^^^^^^^^^^^^^^
</code></pre></div>
<p>用 Chisel 中的 cf interpolator 替换它：</p>
<div class="highlight"><pre><span></span><code>val myUInt = 33.U
printf(cf&quot;myUInt = $myUInt&quot;) // myUInt = 33
</code></pre></div>
<p>请注意，连接 cf”…” 字符串时，需要以 cf”…” 字符串开头：</p>
<div class="highlight"><pre><span></span><code>// 不能插入第二个字符串
val myUInt = 33.U
printf(&quot;my normal string&quot; + cf&quot;myUInt = $myUInt&quot;)
</code></pre></div>
<h3 id="_17">简单的格式化<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h3>
<p>其他格式如下所示：</p>
<div class="highlight"><pre><span></span><code>val myUInt = 33.U
// 十六进制
printf(cf&quot;myUInt = 0x$myUInt%x&quot;) // myUInt = 0x21
print(cf&quot;myUInt = $myUInt%b&quot;) // myUInt = 100001
// 字符
print(cf&quot;myUInt = $myUInt%c&quot;) // myUInt = !
</code></pre></div>
<h3 id="_18">聚合数据类型<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h3>
<p>Chisel 为 Vec 和 Bundle 类型提供默认的 “pretty-printing”。Vec 的默认打印类似于在 Scala 中打印 Seq 或 List，而打印 Bundle 类似于打印 Scala Map。</p>
<div class="highlight"><pre><span></span><code>val myVec = VecInit(5.U, 10.U, 13.U)
printf(cf&quot;myVec = $myVec&quot;) // myVec = Vec(5, 10, 13) // myVec = Vec(5, 10, 13)

val myBundle = Wire(new Bundle {
  val foo = UInt()
  val bar = UInt()
})
myBundle.foo := 3.U
myBundle.bar := 11.U
printf(cf&quot;myBundle = $myBundle&quot;) // myBundle = Bundle(a -&gt; 3, b -&gt; 11)
</code></pre></div>
<h3 id="_19">自定义打印<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h3>
<p>Chisel 也为用户定义的 Bundle 提供自定义打印的功能。</p>
<div class="highlight"><pre><span></span><code>class Message extends Bundle {
  val valid = Bool()
  val addr = UInt(32.W)
  val length = UInt(4.W)
  val data = UInt(64.W)
  override def toPrintable: Printable = {
    val char = Mux(valid, &#39;v&#39;.U, &#39;-&#39;.U)
    cf&quot;Message:\n&quot; +
    cf&quot;  valid  : $char%c\n&quot; +
    cf&quot;  addr   : $addr%x\n&quot; +
    cf&quot;  length : $length\n&quot; +
    cf&quot;  data   : $data%x\n&quot;
  }
}

val myMessage = Wire(new Message)
myMessage.valid := true.B
myMessage.addr := &quot;h1234&quot;.U
myMessage.length := 10.U
myMessage.data := &quot;hdeadbeef&quot;.U

printf(cf&quot;$myMessage&quot;)
</code></pre></div>
<p>这会得到下面的输出：</p>
<div class="highlight"><pre><span></span><code>Message:
  valid  : v
  addr   : 0x00001234
  length : 10
  data   : 0x00000000deadbeef
</code></pre></div>
<p>注意在 <code>cf</code> 插入字符串之间使用的 <code>+</code>。<code>cf</code> 插入的结果可以通过 <code>+</code> 操作符来连接。</p>
<h2 id="c">C 风格<a class="headerlink" href="#c" title="Permanent link">&para;</a></h2>
<p>Chisel 提供的 <code>printf</code> 风格与其同名的 C 语言风格相似。它接受一个双引号格式字符串和一个可变数量的参数，然后这些参数将打印在时钟上升沿上。Chisel 支持以下格式说明符：</p>
<table>
<thead>
<tr>
<th>格式说明符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%d</code></td>
<td>十进制数</td>
</tr>
<tr>
<td><code>%x</code></td>
<td>十六进制数</td>
</tr>
<tr>
<td><code>%b</code></td>
<td>二进制数</td>
</tr>
<tr>
<td><code>%c</code></td>
<td>8 位 ASCII 字符</td>
</tr>
<tr>
<td><code>%%</code></td>
<td>百分号字符</td>
</tr>
</tbody>
</table>
<p>它还支持一小组转义字符：</p>
<table>
<thead>
<tr>
<th>转义符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\n</code></td>
<td>新行</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>tab</td>
</tr>
<tr>
<td><code>\"</code></td>
<td>双引号字符</td>
</tr>
<tr>
<td><code>\'</code></td>
<td>单引号字符</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>反斜杠字符</td>
</tr>
</tbody>
</table>
<p>注意，单引号不需要转义，但转义是合法的。</p>
<p>因此 printf 的使用方式与 C 中的使用方式非常相似：</p>
<div class="highlight"><pre><span></span><code>val myUInt = 32.U
printf(&quot;myUInt = %d&quot;, myUInt) // myUInt = 32
</code></pre></div>
<h1 id="naming">命名（Naming）<a class="headerlink" href="#naming" title="Permanent link">&para;</a></h1>
<p>从历史上看，Chisel 一直难以可靠的捕捉信号的名称。造成这种情况的原因是，（1）主要依靠映射来查找名称，（2）使用有不可靠行为的 <code>@chiselName</code> 宏。</p>
<p>Chisel 3.4 引入了一个自定义的 Scala 编译器插件，当信号名称被声明时，该插件可以确认信号名称的可靠性和自动捕获。此外，此版本还大量使用了一个新的前缀 API，可以对通过函数调用以编程方式生成的信号进行更可靠的命名。</p>
<p>本节解释了如何在 Chisel 中对信号和模块名称进行命名。有关如何解决系统名称稳定性问题的示例，请参阅 <a href="https://www.chisel-lang.org/chisel3/docs/cookbooks/naming">cookbook</a></p>
<h2 id="_20">编译插件<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code>// 导入接下来示例使用的包
import chisel3._
import chisel3.experimental.{prefix, noPrefix}
</code></pre></div>
<p>使用 Chisel 3.5 的用户需要在 build.sbt 设置中加入一行：</p>
<div class="highlight"><pre><span></span><code>// chiselVersion 是版本号字符串（如，&quot;3.5.3&quot;）
addCompilerPlugin(&quot;edu.berkeley.sc&quot; % &quot;chisel3-plugin&quot; % chiselVersion cross CrossVersion.full)
</code></pre></div>
<p>这个插件将在 Scala 编译器的 ‘typer’ 阶段之后运行。它查找形式为 <code>val x=y</code> 的任何用户代码，其中 <code>x</code> 的类型为 “chisel3.Data”, “chisel3.MemBase” 或 “chisel3.experial.BaseModule”。对于符合此标准的每一行，它都会重写该行。在以下示例中，注释行是上面的行被重写的行。</p>
<p>如果该行在 bundle 声明中或是模块实例化，则会重写该行，将右侧替换为对 <code>autoNameRecursively</code> 的调用，该调用命名信号/模块。</p>
<div class="highlight"><pre><span></span><code>class MyBundle extends Bundle {
  val foo = Input(UInt(3.W))
  // val foo = autoNameRecursively(&quot;foo&quot;)(Input(UInt(3.W)))
}
class Example1 extends Module {
  // val io = autoNameRecursively(&quot;io&quot;)(IO(new Bundle()))
}
// Generated by CIRCT firtool-1.44.0
module Example1(
  input       clock,
              reset,
  input [2:0] io_foo
);

endmodule
</code></pre></div>
<p>否则，它将被重写，以将该名称作为前缀包含在执行 val 声明的右侧时生成的任何信号中：</p>
<div class="highlight"><pre><span></span><code>class Example2 extends Module {
  val in = IO(Input(UInt(2.W)))
  // val in = autoNameRecursively(&quot;in&quot;)(prefix(&quot;in&quot;)(IO(Input(UInt(2.W)))))

  val out = IO(Output(UInt(2.W)))
  // val out = autoNameRecursively(&quot;out&quot;)(prefix(&quot;out&quot;)(IO(Output(UInt(2.W))))

  def inXin() = in * in

  val add = 3.U + inXin()
  // val add = autoNameRecursively(&quot;add&quot;)(prefix(&quot;add&quot;)(3.U + inXin()))
  // 注意，乘法的中间结果以 add 为前缀

  out := add + 1.U
}
// Generated by CIRCT firtool-1.44.0
module Example2(
  input        clock,
               reset,
  input  [1:0] in,
  output [1:0] out
);

  assign out = in * in;
endmodule
</code></pre></div>
<p>前缀也可以源自一个连接左边的信号名称。虽然这不是依靠编译器插件实现的，但他的行为类似于：</p>
<div class="highlight"><pre><span></span><code>class ConnectPrefixing extends Module {
  val in = IO(Input(UInt(2.W)))
  // val in = autoNameRecursively(&quot;in&quot;)(prefix(&quot;in&quot;)IO(Input(UInt(2.W))))

  val out = IO(Output(UInt(2.W)))
  // val out = autoNameRecursively(&quot;out&quot;)(prefix(&quot;out&quot;)IO(Output(UInt(2.W))))

  out := { // 从技术上讲，它不包含在 AutoNameRecurative 或 Prefix 中
    // 但是 Chisel 运行时仍然会使用 out 作为前缀
    val double = in * in
    // val double = autoNameRecursively(&quot;double&quot;)(prefix(&quot;double&quot;)(in * in))
    double + 1.U
  }
}
// Generated by CIRCT firtool-1.44.0
module ConnectPrefixing(
  input        clock,
               reset,
  input  [1:0] in,
  output [1:0] out
);

  assign out = in * in + 2&#39;h1;
endmodule
</code></pre></div>
<p>注意，如果硬件类型嵌套在 <code>Option</code> 或 <code>Iterable</code> 的子类型中，则命名也有效：</p>
<div class="highlight"><pre><span></span><code>class Example3 extends Module {
  val in = IO(Input(UInt(2.W)))
  // val in = autoNameRecursively(&quot;in&quot;)(prefix(&quot;in&quot;)(IO(Input(UInt(2.W)))))

  val out = IO(Output(UInt()))
  // val out = autoNameRecursively(&quot;out&quot;)(prefix(&quot;out&quot;)(IO(Output(UInt()))))

  def func() = {
    val delay = RegNext(in)
    delay + 1.U
  }

  val opt = Some(func())
  // 注意 func() 中的寄存器是用 opt 作为前缀的
  // val opt = autoNameRecursively(&quot;opt&quot;)(prefix(&quot;opt&quot;)(Some(func()))

  out := opt.get + 1.U
}
// Generated by CIRCT firtool-1.44.0
module Example3(
  input        clock,
               reset,
  input  [1:0] in,
  output [1:0] out
);

  reg [1:0] opt_delay;
  always @(posedge clock)
    opt_delay &lt;= in;
  assign out = opt_delay - 2&#39;h2;
endmodule
</code></pre></div>
<p>还有一个轻微的变体（<code>autoNameRecursivevelyProduct</code>），用于使用 unapply 提供的名称命名硬件：</p>
<div class="highlight"><pre><span></span><code>class UnapplyExample extends Module {
  def mkIO() = (IO(Input(UInt(2.W))), IO(Output(UInt())))
  val (in, out) = mkIO()
  // val (in, out) = autoNameRecursivelyProduct(List(Some(&quot;in&quot;), Some(&quot;out&quot;)))(mkIO())

  out := in
}
// Generated by CIRCT firtool-1.44.0
module UnapplyExample(
  input        clock,
               reset,
  input  [1:0] in,
  output [1:0] out
);

  assign out = in;
endmodule
</code></pre></div>
<p>注意，编译器插件在这些情况下不会插入前缀，因为前缀应该是什么并不明确。鼓励想要前缀的用户提供如下所述的前缀。</p>
<h3 id="_21">前缀<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h3>
<p>如上所示，编译器插件会自动为一些信号添加前缀。但是，用户也可以添加自己的前缀。这对于 ECO 类型的修复特别有用，在这种修复中，需要向模块添加一些逻辑，但又不想影响模块中的其他名称。</p>
<p>在以下示例中，我们在附加逻辑前面加上 “ECO”，其中 Example4 是加入前缀前的 ECO，Example5 是加入前缀后的 ECO：</p>
<div class="highlight"><pre><span></span><code>class Example4 extends Module {
  val in = IO(Input(UInt(2.W)))
  val out = IO(Output(UInt()))

  val add = in + in + in

  out := add + 1.U
}

class Example5 extends Module {
  val in = IO(Input(UInt(2.W)))
  val out = IO(Output(UInt()))

  val add = in + in + in

  out := prefix(&quot;ECO&quot;) { add + 1.U + in }
}
// Generated by CIRCT firtool-1.44.0
module Example4(
  input        clock,
               reset,
  input  [1:0] in,
  output [1:0] out
);

  assign out = {in[0], 1&#39;h0} + in + 2&#39;h1;
endmodule

// Generated by CIRCT firtool-1.44.0
module Example5(
  input        clock,
               reset,
  input  [1:0] in,
  output [1:0] out
);

  assign out = {in[0], 1&#39;h0} + in + in + 2&#39;h1;
endmodule
</code></pre></div>
<p>还要注意，前缀相互附加（包括编译器插件生成的前缀）</p>
<div class="highlight"><pre><span></span><code>class Example6 extends Module {
  val in = IO(Input(UInt(2.W)))
  val out = IO(Output(UInt()))

  val add = prefix(&quot;foo&quot;) { in + in + in }

  out := add
}
// Generated by CIRCT firtool-1.44.0
module Example6(
  input        clock,
               reset,
  input  [1:0] in,
  output [1:0] out
);

  assign out = {in[0], 1&#39;h0} + in;
endmodule
</code></pre></div>
<p>有时你可能希望关闭前缀。如果您正在编写库函数，并且不希望使用前缀，在这种情况下，可以使用 <code>noPrefix</code> 对象：</p>
<div class="highlight"><pre><span></span><code>class Example7 extends Module {
  val in = IO(Input(UInt(2.W)))
  val out = IO(Output(UInt()))

  val add = noPrefix { in + in + in }

  out := add
}
// Generated by CIRCT firtool-1.44.0
module Example7(
  input        clock,
               reset,
  input  [1:0] in,
  output [1:0] out
);

  assign out = {in[0], 1&#39;h0} + in;
endmodule
</code></pre></div>
<h3 id="suggest-a-signals-name-or-the-instance-name-of-a-module">Suggest a Signal’s Name (or the instance name of a Module)<a class="headerlink" href="#suggest-a-signals-name-or-the-instance-name-of-a-module" title="Permanent link">&para;</a></h3>
<p>如果要指定信号的名称，可以使用 <code>.sugestName</code> API。注意，建议的名称仍将作为前缀（包括插件）。您可以一直使用 <code>noPrefix</code> 对象来剥离。</p>
<div class="highlight"><pre><span></span><code>class Example8 extends Module {
  val in = IO(Input(UInt(2.W)))
  val out = IO(Output(UInt()))

  val add = (in + (in + in).suggestName(&quot;foo&quot;))

  out := add
}
// Generated by CIRCT firtool-1.44.0
module Example8(
  input        clock,
               reset,
  input  [1:0] in,
  output [1:0] out
);

  assign out = in + {in[0], 1&#39;h0};
endmodule
</code></pre></div>
<p>注意，使用 <code>.suggestName</code> 不会影响从 val 名称派生的前缀；但是，它可能会影响从连接派生的前缀（如 <code>:=</code>）：</p>
<div class="highlight"><pre><span></span><code>class ConnectionPrefixExample extends Module {
  val in0 = IO(Input(UInt(2.W)))
  val in1 = IO(Input(UInt(2.W)))

  val out0 = {
    val port = IO(Output(UInt()))
    // Even though this suggestName is before mul, the prefix used in this scope
    // is derived from `val out0`, so this does not affect the name of mul
    port.suggestName(&quot;foo&quot;)
    // out0_mul
    val mul = in0 * in1
    port := mul + 1.U
    port
  }

  val out1 = IO(Output(UInt()))
  val out2 = IO(Output(UInt()))

  out1 := {
    // out1_sum
    val sum = in0 + in1
    sum + 1.U
  }
  // Comes after so does *not* affect prefix above
  out1.suggestName(&quot;bar&quot;)

  // Comes before so *does* affect prefix below
  out2.suggestName(&quot;fizz&quot;)
  out2 := {
    // fizz_diff
    val diff = in0 - in1
    diff + 1.U
  }
}
// Generated by CIRCT firtool-1.44.0
module ConnectionPrefixExample(
  input        clock,
               reset,
  input  [1:0] in0,
               in1,
  output [3:0] foo,
  output [1:0] bar,
               fizz
);

  assign foo = {2&#39;h0, in0} * {2&#39;h0, in1} + 4&#39;h1;
  assign bar = in0 + in1 + 2&#39;h1;
  assign fizz = in0 - in1 + 2&#39;h1;
endmodule
</code></pre></div>
<p>如本例所示，这种行为有点不一致，因此在未来的Chisel版本中可能会发生变化。</p>
<h3 id="unnamed-signals-temporaries">“Unnamed signals” 的行为（又名 “Temporaries”）<a class="headerlink" href="#unnamed-signals-temporaries" title="Permanent link">&para;</a></h3>
<p>如果你想表示信号的名称无关紧要，你可以在 val 的名称前面加上 _。Chisel将保留前导的惯例，表示前缀之间的未命名信号。例如：</p>
<div class="highlight"><pre><span></span><code>class TemporaryExample extends Module {
  val in0 = IO(Input(UInt(2.W)))
  val in1 = IO(Input(UInt(2.W)))

  val out = {
    val port = IO(Output(UInt()))
    val _sum = in0 + in1
    port := _sum + 1.U
    port
  }
}
// Generated by CIRCT firtool-1.44.0
module TemporaryExample(
  input        clock,
               reset,
  input  [1:0] in0,
               in1,
  output [1:0] out
);

  assign out = in0 + in1 + 2&#39;h1;
endmodule
</code></pre></div>
<p>如果一个未命名的信号本身被用来生成前缀，那么前导的_将被忽略，以避免在其他嵌套信号的名称中出现双 _。</p>
<div class="highlight"><pre><span></span><code>class TemporaryPrefixExample extends Module {
  val in0 = IO(Input(UInt(2.W)))
  val in1 = IO(Input(UInt(2.W)))
  val out = IO(Output(UInt()))

  val _sum = {
    val x = in0 + in1
    x + 1.U
  }
  out := _sum &amp; 0x2.U
}
// Generated by CIRCT firtool-1.44.0
module TemporaryPrefixExample(
  input        clock,
               reset,
  input  [1:0] in0,
               in1,
  output [1:0] out
);

  assign out = in0 + in1 + 2&#39;h1 &amp; 2&#39;h2;
endmodule
</code></pre></div>
<h3 id="_22">设置一个模块名称<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h3>
<p>如果要指定模块的名称（而不是模块的实例名称），则可以始终覆盖 <code>desiredName</code> 值。注意，可以通过模块的参数来参数化名称。这是一种使模块名称更加稳定的好方法，强烈建议您这样做。</p>
<div class="highlight"><pre><span></span><code>class Example9(width: Int) extends Module {
  override val desiredName = s&quot;EXAMPLE9WITHWIDTH$width&quot;
  val in = IO(Input(UInt(width.W)))
  val out = IO(Output(UInt()))

  val add = (in + (in + in).suggestName(&quot;foo&quot;))

  out := add
}
// Generated by CIRCT firtool-1.44.0
module EXAMPLE9WITHWIDTH8(
  input        clock,
               reset,
  input  [7:0] in,
  output [7:0] out
);

  assign out = in + {in[6:0], 1&#39;h0};
endmodule

// Generated by CIRCT firtool-1.44.0
module EXAMPLE9WITHWIDTH1(
  input  clock,
         reset,
         in,
  output out
);

  assign out = in;
endmodule
</code></pre></div>
<h2 id="_23">映射命名<a class="headerlink" href="#_23" title="Permanent link">&para;</a></h2>
<p>无论编译器插件是否启用，Chisel 构造模块后，都会尝试命名模块的所有成员。这将命名作为模块类字段的所有 val，但不会命名嵌套函数或作用域中的任何 val。</p>
<p>如果插件成功地命名了一个信号，那么映射命名将不会起任何作用。我们计划在未来的 Chisel 版本中取消所有映射命名，但允许插件命名是可选的（但推荐）。</p>
<p>例如，以下模块中的信号处于嵌套范围内；插件成功地命名了它们，但映射命名不能：</p>
<div class="highlight"><pre><span></span><code>class Example10 extends Module {
  {
    val in = IO(Input(UInt(3.W)))
    val out = IO(Output(UInt()))

    val add = in + in

    out := add
  }
}
</code></pre></div>
<h2 id="chiselname">@chiselName<a class="headerlink" href="#chiselname" title="Permanent link">&para;</a></h2>
<p>不再推荐使用此宏，因为它的功能已被编译器插件完全取代。请随意从你的Chisel设计中删除！</p>
<h1 id="unconnected-wires">未连接的线（Unconnected Wires）<a class="headerlink" href="#unconnected-wires" title="Permanent link">&para;</a></h1>
<p>Invalidate API 添加了支持使 Chisel 可以将未连接的导线报告为错误。</p>
<p>Prior to this pull request, Chisel automatically generated a firrtl is invalid for Module IO(), and each Wire() definition. This made it difficult to detect cases where output signals were never driven. Chisel now supports a DontCare element, which may be connected to an output signal, indicating that that signal is intentionally not driven. Unless a signal is driven by hardware or connected to a DontCare, Firrtl will complain with a “not fully initialized” error.
在此 pull 请求之前，Chisel 自动生成一个 firrtl，该 firrtl 对于 <code>Module IO()</code>和每个 <code>Wire()</code> 定义无效。这使得难以检测从未驱动输出信号的情况。Chisel 现在支持 <code>DontCare</code> 元件，该元件可以连接到输出信号，表明该信号是故意不被驱动的。除非信号由硬件驱动或连接到 <code>DontCare</code>，否则 Firrtl 将报告 “not fully initialized” 错误。</p>
<h2 id="api">API<a class="headerlink" href="#api" title="Permanent link">&para;</a></h2>
<p>输出信号可能被连接到 DontCare，当发出 firrtl 的时候生成 <code>a invalid</code>：</p>
<div class="highlight"><pre><span></span><code>class Out extends Bundle { 
  val debug = Bool()
  val debugOption = Bool()
}
val io = new Bundle { val out = new Out }
io.out.debug := true.B
io.out.debugOption := DontCare
</code></pre></div>
<p>这表示故意不驱动信号 <code>io.out.debugOption</code>，firrtl 不应对此信号发出 “not fully initialized” 错误。</p>
<p>这可以应用于集合以及单个信号：</p>
<div class="highlight"><pre><span></span><code>import chisel3._
class ModWithVec extends Module {
  // ...
  val nElements = 5
  val io = IO(new Bundle {
    val outs = Output(Vec(nElements, Bool()))
  })
  io.outs &lt;&gt; DontCare
  // ...
}

class TrivialInterface extends Bundle {
  val in  = Input(Bool())
  val out = Output(Bool())
}

class ModWithTrivalInterface extends Module {
  // ...
  val io = IO(new TrivialInterface)
  io &lt;&gt; DontCare
  // ...
}
</code></pre></div>
<h2 id="_24">确定未连接的元素<a class="headerlink" href="#_24" title="Permanent link">&para;</a></h2>
<p>我有一个 42 条线的接口。他们之中谁是未连接的？</p>
<p>firrtl 的错误信息应该包含一些东西：</p>
<div class="highlight"><pre><span></span><code>firrtl.passes.CheckInitialization$RefNotInitializedException:  @[:@6.4] : [module Router]  Reference io is not fully initialized.
   @[Decoupled.scala 38:19:@48.12] : node _GEN_23 = mux(and(UInt&lt;1&gt;(&quot;h1&quot;), eq(UInt&lt;2&gt;(&quot;h3&quot;), _T_84)), _GEN_2, VOID) @[Decoupled.scala 38:19:@48.12]
   @[Router.scala 78:30:@44.10] : node _GEN_36 = mux(_GEN_0.ready, _GEN_23, VOID) @[Router.scala 78:30:@44.10]
   @[Router.scala 75:26:@39.8] : node _GEN_54 = mux(io.in.valid, _GEN_36, VOID) @[Router.scala 75:26:@39.8]
   @[Router.scala 70:50:@27.6] : node _GEN_76 = mux(io.load_routing_table_request.valid, VOID, _GEN_54) @[Router.scala 70:50:@27.6]
   @[Router.scala 65:85:@19.4] : node _GEN_102 = mux(_T_62, VOID, _GEN_76) @[Router.scala 65:85:@19.4]
   : io.outs[3].bits.body &lt;= _GEN_102
</code></pre></div>
<p>第一行是初始化错误报告。接下来一行，缩进并以源文件的行数开头表示有问题的信号。不幸的是，如果他们在包含选择器的 <code>when</code>
语句中，可能会很难读懂。最后一行中，缩进并以冒号开头表示未初始化的组件。这个示例（来源于 <a href="https://github.com/ucb-bar/chisel-tutorial/blob/release/src/main/scala/examples/Router.scala">Router tutorial</a>）输出队列未初始化时产生的。以前的代码为：</p>
<div class="highlight"><pre><span></span><code>io.outs.foreach { out =&gt; out.noenq() }
</code></pre></div>
<p>它初始化了队列的有效位，但没有初始化实际的输出值。修改后的代码是：</p>
<div class="highlight"><pre><span></span><code>io.outs.foreach { out =&gt;
  out.bits := 0.U.asTypeOf(out.bits)
  out.noenq()
}
</code></pre></div>
<h1 id="chisel-vs-scala">Chisel 类型 vs Scala 类型<a class="headerlink" href="#chisel-vs-scala" title="Permanent link">&para;</a></h1>
<p>Scala 编译器无法区分 Chisel 对硬件的表示，如 <code>false.B</code>, <code>Reg(Bool())</code> 和纯 Chisel 类型（如 <code>Bool()</code> ）。当需要硬件时，可以通过 Chisel 类型获得运行时错误，反之亦然。</p>
<h2 id="scala-vs-chisel-vs">Scala 类型 vs Chisel 类型 vs 硬件类型<a class="headerlink" href="#scala-vs-chisel-vs" title="Permanent link">&para;</a></h2>
<p>Data 的 Scala 类型由 Scala 编译器识别，例如中的 <code>Bool</code>, <code>Decoupled[UInt]</code> 或 <code>MyBundle</code></p>
<div class="highlight"><pre><span></span><code>class MyBundle(w: Int) extends Bundle {
  val foo = UInt(w.W)
  val bar = UInt(w.W)
}
</code></pre></div>
<p>Chisel 类型的 <code>Data</code> 是一个 Scala 对象。它通过名称及其类型（包括宽度）捕获实际存在的所有字段。例如，<code>MyBundle(3)</code> 创建了一个 Chisel 类型，其中包含字段 <code>foo:UInt(3.W)</code>, <code>bar:UInt(3.W)</code>。</p>
<p>硬件类型是指与可合成硬件绑定的 <code>Data</code>。例如 <code>false.B</code> 或 <code>Reg(Bool())</code>。绑定决定了每个字段的实际方向性，它不是 Chisel 类型的属性。</p>
<p>字符是一种 <code>Data</code>，它可以作为文字值重新表示，而无需包装在 Wire、Reg 或 IO 中。</p>
<h2 id="chisel-vs-vs">Chisel 类型 vs 硬件类型 vs 字符<a class="headerlink" href="#chisel-vs-vs" title="Permanent link">&para;</a></h2>
<p>下面的代码演示了具有相同 Scala 类型（<code>MyBundle</code>）的对象如何具有不同的属性。</p>
<div class="highlight"><pre><span></span><code>import chisel3.experimental.BundleLiterals._

class MyModule(gen: () =&gt; MyBundle) extends Module {
                                                            //   Hardware   Literal
    val xType:    MyBundle     = new MyBundle(3)            //      -          -
    val dirXType: MyBundle     = Input(new MyBundle(3))     //      -          -
    val xReg:     MyBundle     = Reg(new MyBundle(3))       //      x          -
    val xIO:      MyBundle     = IO(Input(new MyBundle(3))) //      x          -
    val xRegInit: MyBundle     = RegInit(xIO)               //      x          -
    val xLit:     MyBundle     = xType.Lit(                 //      x          x
      _.foo -&gt; 0.U(3.W),
      _.bar -&gt; 0.U(3.W)
    )
    val y:        MyBundle = gen()                          //      ?          ?

    // Need to initialize all hardware values
    xReg := DontCare
}
</code></pre></div>
<h2 id="chisel-type-vs-hardware-specific-functions-and-errors">Chisel Type vs Hardware – Specific Functions and Errors<a class="headerlink" href="#chisel-type-vs-hardware-specific-functions-and-errors" title="Permanent link">&para;</a></h2>
<p><code>.asTypeOf</code> 对硬件类型和 Chisel 类型都有效:</p>
<div class="highlight"><pre><span></span><code>elaborate(new Module {
  val chiselType = new MyBundle(3)
  val hardware = Wire(new MyBundle(3))
  hardware := DontCare
  val a = 0.U.asTypeOf(chiselType)
  val b = 0.U.asTypeOf(hardware)
})
</code></pre></div>
<p>只能 <code>:=</code> 到硬件：</p>
<div class="highlight"><pre><span></span><code>// Do this...
elaborate(new Module {
  val hardware = Wire(new MyBundle(3))
  hardware := DontCare
})
// Not this...
elaborate(new Module {
  val chiselType = new MyBundle(3)
  chiselType := DontCare
})
// chisel3.package$ExpectedHardwareException: data to be connected &#39;MyBundle&#39; must be hardware, not a bare Chisel type. Perhaps you forgot to wrap it in Wire(_) or IO(_)?
//  at ... ()
//  at repl.MdocSession$MdocApp$$anonfun$21$$anonfun$apply$21$$anon$3.&lt;init&gt;(chisel-type-vs-scala-type.md:90)
//  at repl.MdocSession$MdocApp$$anonfun$21$$anonfun$apply$21.apply(chisel-type-vs-scala-type.md:88)
//  at repl.MdocSession$MdocApp$$anonfun$21$$anonfun$apply$21.apply(chisel-type-vs-scala-type.md:88)
//  at ... ()
//  at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace)
</code></pre></div>
<p>只能从硬件 <code>:=</code> 连接：</p>
<div class="highlight"><pre><span></span><code>// Do this...
elaborate(new Module {
  val hardware = IO(new MyBundle(3))
  val moarHardware = Wire(new MyBundle(3))
  moarHardware := DontCare
  hardware := moarHardware
})
// Not this...
elaborate(new Module {
  val hardware = IO(new MyBundle(3))
  val chiselType = new MyBundle(3)
  hardware := chiselType
})
// chisel3.package$ExpectedHardwareException: data to be connected &#39;MyBundle&#39; must be hardware, not a bare Chisel type. Perhaps you forgot to wrap it in Wire(_) or IO(_)?
//  at ... ()
//  at repl.MdocSession$MdocApp$$anonfun$29$$anonfun$apply$27$$anon$5.&lt;init&gt;(chisel-type-vs-scala-type.md:115)
//  at repl.MdocSession$MdocApp$$anonfun$29$$anonfun$apply$27.apply(chisel-type-vs-scala-type.md:112)
//  at repl.MdocSession$MdocApp$$anonfun$29$$anonfun$apply$27.apply(chisel-type-vs-scala-type.md:112)
//  at ... ()
//  at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace)
</code></pre></div>
<p>必须将硬件传递给 <code>chiselTypeOf</code>：</p>
<div class="highlight"><pre><span></span><code>// Do this...
elaborate(new Module {
  val hardware = Wire(new MyBundle(3))
  hardware := DontCare
  val chiselType = chiselTypeOf(hardware)
})
// Not this...
elaborate(new Module {
  val chiselType = new MyBundle(3)
  val crash = chiselTypeOf(chiselType)
})
// chisel3.package$ExpectedHardwareException: &#39;MyBundle&#39; must be hardware, not a bare Chisel type. Perhaps you forgot to wrap it in Wire(_) or IO(_)?
//  at ... ()
//  at repl.MdocSession$MdocApp$$anonfun$37$$anonfun$apply$34$$anon$7$$anonfun$39$$anonfun$apply$36.apply(chisel-type-vs-scala-type.md:138)
//  at repl.MdocSession$MdocApp$$anonfun$37$$anonfun$apply$34$$anon$7$$anonfun$39$$anonfun$apply$36.apply(chisel-type-vs-scala-type.md:138)
//  at chisel3.experimental.prefix$.apply(prefix.scala:50)
//  at repl.MdocSession$MdocApp$$anonfun$37$$anonfun$apply$34$$anon$7$$anonfun$39.apply(chisel-type-vs-scala-type.md:138)
//  at repl.MdocSession$MdocApp$$anonfun$37$$anonfun$apply$34$$anon$7$$anonfun$39.apply(chisel-type-vs-scala-type.md)
//  at chisel3.internal.plugin.package$.autoNameRecursively(package.scala:33)
//  at repl.MdocSession$MdocApp$$anonfun$37$$anonfun$apply$34$$anon$7.&lt;init&gt;(chisel-type-vs-scala-type.md:138)
//  at repl.MdocSession$MdocApp$$anonfun$37$$anonfun$apply$34.apply(chisel-type-vs-scala-type.md:136)
//  at repl.MdocSession$MdocApp$$anonfun$37$$anonfun$apply$34.apply(chisel-type-vs-scala-type.md:136)
//  at ... ()
//  at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace)
</code></pre></div>
<p>必须把硬件类型传递给 <code>*Init</code>：</p>
<div class="highlight"><pre><span></span><code>// Do this...
elaborate(new Module {
  val hardware = Wire(new MyBundle(3))
  hardware := DontCare
  val moarHardware = WireInit(hardware)
})
// Not this...
elaborate(new Module {
  val crash = WireInit(new MyBundle(3))
})
// chisel3.package$ExpectedHardwareException: wire initializer &#39;MyBundle&#39; must be hardware, not a bare Chisel type. Perhaps you forgot to wrap it in Wire(_) or IO(_)?
//  at ... ()
//  at repl.MdocSession$MdocApp$$anonfun$44$$anonfun$apply$40$$anon$9$$anonfun$45$$anonfun$apply$41.apply(chisel-type-vs-scala-type.md:160)
//  at repl.MdocSession$MdocApp$$anonfun$44$$anonfun$apply$40$$anon$9$$anonfun$45$$anonfun$apply$41.apply(chisel-type-vs-scala-type.md:160)
//  at chisel3.experimental.prefix$.apply(prefix.scala:50)
//  at repl.MdocSession$MdocApp$$anonfun$44$$anonfun$apply$40$$anon$9$$anonfun$45.apply(chisel-type-vs-scala-type.md:160)
//  at repl.MdocSession$MdocApp$$anonfun$44$$anonfun$apply$40$$anon$9$$anonfun$45.apply(chisel-type-vs-scala-type.md)
//  at chisel3.internal.plugin.package$.autoNameRecursively(package.scala:33)
//  at repl.MdocSession$MdocApp$$anonfun$44$$anonfun$apply$40$$anon$9.&lt;init&gt;(chisel-type-vs-scala-type.md:160)
//  at repl.MdocSession$MdocApp$$anonfun$44$$anonfun$apply$40.apply(chisel-type-vs-scala-type.md:159)
//  at repl.MdocSession$MdocApp$$anonfun$44$$anonfun$apply$40.apply(chisel-type-vs-scala-type.md:159)
//  at ... ()
//  at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace)
</code></pre></div>
<p>不能把硬件传递给 <code>Wire</code>, <code>Reg</code>, <code>IO</code>:</p>
<div class="highlight"><pre><span></span><code>// Do this...
elaborate(new Module {
  val hardware = Wire(new MyBundle(3))
  hardware := DontCare
})
// Not this...
elaborate(new Module {
  val hardware = Wire(new MyBundle(3))
  val crash = Wire(hardware)
})
// chisel3.package$ExpectedChiselTypeException: wire type &#39;_44_Anon.hardware: Wire[MyBundle]&#39; must be a Chisel type, not hardware
//  at ... ()
//  at repl.MdocSession$MdocApp$$anonfun$49$$anonfun$apply$44$$anon$11$$anonfun$51$$anonfun$apply$47.apply(chisel-type-vs-scala-type.md:182)
//  at repl.MdocSession$MdocApp$$anonfun$49$$anonfun$apply$44$$anon$11$$anonfun$51$$anonfun$apply$47.apply(chisel-type-vs-scala-type.md:182)
//  at chisel3.experimental.prefix$.apply(prefix.scala:50)
//  at repl.MdocSession$MdocApp$$anonfun$49$$anonfun$apply$44$$anon$11$$anonfun$51.apply(chisel-type-vs-scala-type.md:182)
//  at repl.MdocSession$MdocApp$$anonfun$49$$anonfun$apply$44$$anon$11$$anonfun$51.apply(chisel-type-vs-scala-type.md)
//  at chisel3.internal.plugin.package$.autoNameRecursively(package.scala:33)
//  at repl.MdocSession$MdocApp$$anonfun$49$$anonfun$apply$44$$anon$11.&lt;init&gt;(chisel-type-vs-scala-type.md:182)
//  at repl.MdocSession$MdocApp$$anonfun$49$$anonfun$apply$44.apply(chisel-type-vs-scala-type.md:180)
//  at repl.MdocSession$MdocApp$$anonfun$49$$anonfun$apply$44.apply(chisel-type-vs-scala-type.md:180)
//  at ... ()
//  at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace)
</code></pre></div>
<p><code>.Lit</code> 只能被 Chisel 类型调用：</p>
<div class="highlight"><pre><span></span><code>// Do this...
elaborate(new Module {
  val hardwareLit = (new MyBundle(3)).Lit(
    _.foo -&gt; 0.U,
    _.bar -&gt; 0.U
  )
})
//Not this...
elaborate(new Module {
  val hardware = Wire(new MyBundle(3))
  val crash = hardware.Lit(
    _.foo -&gt; 0.U,
    _.bar -&gt; 0.U
  )
})
// chisel3.package$ExpectedChiselTypeException: bundle literal constructor model &#39;_52_Anon.hardware: Wire[MyBundle]&#39; must be a Chisel type, not hardware
//  at ... ()
//  at repl.MdocSession$MdocApp$$anonfun$54$$anonfun$apply$52$$anon$13$$anonfun$56$$anonfun$apply$55.apply(chisel-type-vs-scala-type.md:206)
//  at repl.MdocSession$MdocApp$$anonfun$54$$anonfun$apply$52$$anon$13$$anonfun$56$$anonfun$apply$55.apply(chisel-type-vs-scala-type.md:206)
//  at chisel3.experimental.prefix$.apply(prefix.scala:50)
//  at repl.MdocSession$MdocApp$$anonfun$54$$anonfun$apply$52$$anon$13$$anonfun$56.apply(chisel-type-vs-scala-type.md:206)
//  at repl.MdocSession$MdocApp$$anonfun$54$$anonfun$apply$52$$anon$13$$anonfun$56.apply(chisel-type-vs-scala-type.md)
//  at chisel3.internal.plugin.package$.autoNameRecursively(package.scala:33)
//  at repl.MdocSession$MdocApp$$anonfun$54$$anonfun$apply$52$$anon$13.&lt;init&gt;(chisel-type-vs-scala-type.md:206)
//  at repl.MdocSession$MdocApp$$anonfun$54$$anonfun$apply$52.apply(chisel-type-vs-scala-type.md:204)
//  at repl.MdocSession$MdocApp$$anonfun$54$$anonfun$apply$52.apply(chisel-type-vs-scala-type.md:204)
//  at ... ()
//  at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace)
</code></pre></div>
<p>在 Bundle 定义中只能使用 Chisel 类型：</p>
<div class="highlight"><pre><span></span><code>// Do this...
elaborate(new Module {
  val hardware = Wire(new Bundle {
    val nested = new MyBundle(3)
  })
  hardware := DontCare
})
// Not this...
elaborate(new Module {
  val crash = Wire(new Bundle {
    val nested = Wire(new MyBundle(3))
  })
})
// chisel3.package$ExpectedChiselTypeException: Bundle: AnonymousBundle contains hardware fields: nested: _60_Anon.crash_nested: Wire[MyBundle]
//  at ... ()
//  at repl.MdocSession$MdocApp$$anonfun$61$$anonfun$apply$60$$anon$16$$anonfun$62$$anonfun$apply$61.apply(chisel-type-vs-scala-type.md:232)
//  at repl.MdocSession$MdocApp$$anonfun$61$$anonfun$apply$60$$anon$16$$anonfun$62$$anonfun$apply$61.apply(chisel-type-vs-scala-type.md:232)
//  at chisel3.experimental.prefix$.apply(prefix.scala:50)
//  at repl.MdocSession$MdocApp$$anonfun$61$$anonfun$apply$60$$anon$16$$anonfun$62.apply(chisel-type-vs-scala-type.md:232)
//  at repl.MdocSession$MdocApp$$anonfun$61$$anonfun$apply$60$$anon$16$$anonfun$62.apply(chisel-type-vs-scala-type.md)
//  at chisel3.internal.plugin.package$.autoNameRecursively(package.scala:33)
//  at repl.MdocSession$MdocApp$$anonfun$61$$anonfun$apply$60$$anon$16.&lt;init&gt;(chisel-type-vs-scala-type.md:232)
//  at repl.MdocSession$MdocApp$$anonfun$61$$anonfun$apply$60.apply(chisel-type-vs-scala-type.md:231)
//  at repl.MdocSession$MdocApp$$anonfun$61$$anonfun$apply$60.apply(chisel-type-vs-scala-type.md:231)
//  at ... ()
//  at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace)
</code></pre></div>
<p>只能在硬件上调用 <code>directionOf</code>：</p>
<div class="highlight"><pre><span></span><code>import chisel3.reflect.DataMirror

class Child extends Module{
  val hardware = IO(new MyBundle(3))
  hardware := DontCare
  val chiselType = new MyBundle(3)
}
// Do this...
elaborate(new Module {
  val child = Module(new Child())
  child.hardware := DontCare
  val direction = DataMirror.directionOf(child.hardware)
})
// Not this...
elaborate(new Module {
val child = Module(new Child())
  child.hardware := DontCare
  val direction = DataMirror.directionOf(child.chiselType)
})
// chisel3.package$ExpectedHardwareException: node requested directionality on &#39;MyBundle&#39; must be hardware, not a bare Chisel type. Perhaps you forgot to wrap it in Wire(_) or IO(_)?
//  at ... ()
//  at repl.MdocSession$MdocApp$$anonfun$70$$anonfun$apply$68$$anon$19.&lt;init&gt;(chisel-type-vs-scala-type.md:271)
//  at repl.MdocSession$MdocApp$$anonfun$70$$anonfun$apply$68.apply(chisel-type-vs-scala-type.md:268)
//  at repl.MdocSession$MdocApp$$anonfun$70$$anonfun$apply$68.apply(chisel-type-vs-scala-type.md:268)
//  at ... ()
//  at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace)
</code></pre></div>
<p>可以在硬件类型和 Chisel 类型上调用 <code>specifiedDirectionOf</code>：</p>
<div class="highlight"><pre><span></span><code>elaborate(new Module {
  val child = Module(new Child())
  child.hardware := DontCare
  val direction0 = DataMirror.specifiedDirectionOf(child.hardware)
  val direction1 = DataMirror.specifiedDirectionOf(child.chiselType)
})
</code></pre></div>
<p><code>.asInstanceOf</code> vs <code>.asTypeOf</code> vs <code>chiselTypeOf</code>
<code>.asInstanceOf</code> 是一个 Scala 运行时强制转换, 通常用来告诉编译器你有比他更多的信息来转换 Scala 类型：</p>
<div class="highlight"><pre><span></span><code>class ScalaCastingModule(gen: () =&gt; Bundle) extends Module {
  val io = IO(Output(gen().asInstanceOf[MyBundle]))
  io.foo := 0.U
}
</code></pre></div>
<p>如果我们确实拥有比编译器更多的信息，那么这是有效的：</p>
<div class="highlight"><pre><span></span><code>elaborate(new ScalaCastingModule( () =&gt; new MyBundle(3)))
</code></pre></div>
<p>但如果我们错了，会得到 Scala 的运行时异常：</p>
<div class="highlight"><pre><span></span><code>class NotMyBundle extends Bundle {val baz = Bool()}
elaborate(new ScalaCastingModule(() =&gt; new NotMyBundle()))
// java.lang.ClassCastException: class repl.MdocSession$MdocApp$$anonfun$79$NotMyBundle$1 cannot be cast to class repl.MdocSession$MdocApp$MyBundle (repl.MdocSession$MdocApp$$anonfun$79$NotMyBundle$1 and repl.MdocSession$MdocApp$MyBundle are in unnamed module of loader scala.reflect.internal.util.AbstractFileClassLoader @5aa4e5fa)
//  at ... ()
//  at repl.MdocSession$MdocApp$ScalaCastingModule$$anonfun$76$$anonfun$apply$71$$anonfun$apply$72$$anonfun$apply$73.apply(chisel-type-vs-scala-type.md:293)
//  at repl.MdocSession$MdocApp$ScalaCastingModule$$anonfun$76$$anonfun$apply$71$$anonfun$apply$72$$anonfun$apply$73.apply(chisel-type-vs-scala-type.md:293)
//  at chisel3.SpecifiedDirection$.specifiedDirection(Data.scala:63)
//  at chisel3.Output$.apply(Data.scala:266)
//  at repl.MdocSession$MdocApp$ScalaCastingModule$$anonfun$76$$anonfun$apply$71$$anonfun$apply$72.apply(chisel-type-vs-scala-type.md:293)
//  at repl.MdocSession$MdocApp$ScalaCastingModule$$anonfun$76$$anonfun$apply$71$$anonfun$apply$72.apply(chisel-type-vs-scala-type.md:293)
//  at chisel3.IO$.apply(IO.scala:27)
//  at chisel3.experimental.BaseModule.IO(Module.scala:620)
//  at repl.MdocSession$MdocApp$ScalaCastingModule$$anonfun$76$$anonfun$apply$71.apply(chisel-type-vs-scala-type.md:293)
//  at repl.MdocSession$MdocApp$ScalaCastingModule$$anonfun$76$$anonfun$apply$71.apply(chisel-type-vs-scala-type.md:293)
//  at chisel3.experimental.prefix$.apply(prefix.scala:50)
//  at repl.MdocSession$MdocApp$ScalaCastingModule$$anonfun$76.apply(chisel-type-vs-scala-type.md:293)
//  at repl.MdocSession$MdocApp$ScalaCastingModule$$anonfun$76.apply(chisel-type-vs-scala-type.md)
//  at chisel3.internal.plugin.package$.autoNameRecursively(package.scala:33)
//  at repl.MdocSession$MdocApp$ScalaCastingModule.&lt;init&gt;(chisel-type-vs-scala-type.md:293)
//  at repl.MdocSession$MdocApp$$anonfun$79$$anonfun$apply$75.apply(chisel-type-vs-scala-type.md:309)
//  at repl.MdocSession$MdocApp$$anonfun$79$$anonfun$apply$75.apply(chisel-type-vs-scala-type.md:309)
//  at ... ()
//  at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace)
</code></pre></div>
<p><code>.asTypeOf</code> 是从一个 <code>Data</code> 子类到另一个子类的转换。它通常用于将数据分配给全零，如这一节 <a href="https://www.chisel-lang.org/chisel3/docs/cookbooks/cookbook.html#how-can-i-tieoff-a-bundlevec-to-0">cookbook</a> 中所述，但也可以用于将一种 Chisel 类型转换为另一种：</p>
<div class="highlight"><pre><span></span><code>class SimilarToMyBundle(w: Int) extends Bundle{
  val foobar = UInt((2*w).W)
}

ChiselStage.emitSystemVerilog(new Module {
  val in = IO(Input(new MyBundle(3)))
  val out = IO(Output(new SimilarToMyBundle(3)))

  out := in.asTypeOf(out)
})
// res12: String = &quot;&quot;&quot;// Generated by CIRCT firtool-1.44.0
// module _82_Anon( // &lt;stdin&gt;:3:10
//   input        clock,    // &lt;stdin&gt;:4:11
//                reset,    // &lt;stdin&gt;:5:11
//   input  [2:0] in_foo,   // chisel-type-vs-scala-type.md:324:14
//                in_bar,   // chisel-type-vs-scala-type.md:324:14
//   output [5:0] out_foobar    // chisel-type-vs-scala-type.md:325:15
// );
// 
//   assign out_foobar = {in_foo, in_bar};  // &lt;stdin&gt;:3:10, chisel-type-vs-scala-type.md:327:21
// endmodule
// 
// &quot;&quot;&quot;
</code></pre></div>
<p>与 <code>asInstanceOf</code> 和 <code>asTypeOf</code> 不同，<code>chiselTypeOf</code> 不是强制转换操作。它返回一个 Scala 对象，如上面的例子所示，该对象可以用来创建更多的 Chisel 类型和与现有硬件具有相同 Chisel 类型的硬件。</p>
<h1 id="connectable-operators">连接操作符（Connectable Operators）<a class="headerlink" href="#connectable-operators" title="Permanent link">&para;</a></h1>
<h2 id="_25">术语<a class="headerlink" href="#_25" title="Permanent link">&para;</a></h2>
<ul>
<li>“Chisel type” - 一种没有绑定在硬件上</li>
</ul>
<div class="highlight"><pre><span></span><code>Data
</code></pre></div>
<p>，即不是一个组件。</p>
<ul>
<li>
<p>例如，<code>UInt(3.W)</code>, <code>new Bundle(...)</code>, <code>Vec(3, SInt(2.W))</code> 都是 Chisel type</p>
</li>
<li>
<p><code>Aggregate</code> - 一种包含其它 Chisel type 或者组件的 Chisel type 或者组件。（即 <code>Vec</code>, <code>Record</code>, 或者 <code>Bundle</code>）</p>
</li>
<li>
<p><code>Element</code> - 一种不包含其它 Chisel type 或者 compnoent 的 Chisel type 或者组件。（即 <code>UInt</code>, <code>SInt</code>, <code>Clock</code>, <code>Bool</code> 等）</p>
</li>
<li>
<p>“组件” - 一种绑定在硬件上的<code>Data（IO,Reg,Wire</code>等）</p>
</li>
<li>
<p>例如，<code>Wire(UInt(3.W))</code> 是一个组件，它的 Chisel type 是 UInt(3.W)</p>
</li>
<li>
<p>“成员” - 一种 Chisel type 或者组件，或者他们的任何子集（可以是</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code>Aggregate
</code></pre></div>
<p>或</p>
<div class="highlight"><pre><span></span><code>Element
</code></pre></div>
<p>）</p>
<ul>
<li>例如 <code>Vec(3, UInt(2.W))(0)</code> 是父项 Chisel type 的一个成员</li>
<li>例如 <code>Wire(Vec(3, UInt(2.W)))(0)</code> 是父项 <code>Wire</code> 组件的一个成员</li>
<li>
<p>例如 <code>IO(Decoupled(Bool)).ready</code> 是父项 <code>IO</code> 组件的一个成员</p>
</li>
<li>
<p>“relative alignment” - 同一个组件或者 Chisel type 的两个成员是否对齐/翻转</p>
</li>
<li>
<p>在下面的章节中详细定义</p>
</li>
<li>
<p>“structural type check” - 如果</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code>A
</code></pre></div>
<p>和</p>
<div class="highlight"><pre><span></span><code>B
</code></pre></div>
<p>有匹配的绑定名称和类型（</p>
<div class="highlight"><pre><span></span><code>Record
</code></pre></div>
<p>和</p>
<div class="highlight"><pre><span></span><code>Vector
</code></pre></div>
<p>和</p>
<div class="highlight"><pre><span></span><code>Element
</code></pre></div>
<p>），向量大小，</p>
<div class="highlight"><pre><span></span><code>Element
</code></pre></div>
<p>类型（UInt/SInt/Bool/Clock 等）。Chisel type</p>
<div class="highlight"><pre><span></span><code>A
</code></pre></div>
<p>和 Chisel type</p>
<div class="highlight"><pre><span></span><code>B
</code></pre></div>
<p>在结构上等价。</p>
<ul>
<li>
<p>忽略 relative alignment</p>
</li>
<li>
<p>“alignment type check” - 如果 <code>A</code> 与 <code>A</code> 的 relative alignment 的每一个成员都与 <code>B</code> 的 relative alignment 的结构对应的成员相同，则 Chisel type <code>A</code> 和另一个 Chisel type <code>B</code> 匹配对齐。</p>
</li>
</ul>
<h2 id="_26">概述<a class="headerlink" href="#_26" title="Permanent link">&para;</a></h2>
<p>连接操作符是连接 Chisel 硬件组件到另一个 Chisel 硬件组件的标准方法。</p>
<p>所有连接操作符都需要两个硬件组件（生产者和消费者）结构类型等价。</p>
<p>结构类型等效规则的一个例外是使用 <code>connectable</code> 机制，在本文档末尾的本节中对此进行了详细说明。</p>
<p><code>Aggregate</code>（<code>Record</code>, <code>Vec</code>, <code>Bundle</code>）Chisel 类型可以包括相对于彼此翻转的数据成员。因此，在两个 Chisel 组件之间存在许多所需的连接行为。以下是 Chisel 连接操作符：</p>
<ul>
<li><code>c := p</code> (单向): 将 p 的所有成员连接到 c; 需要 c 和 p 都没有翻转的成员</li>
<li><code>c :#= p</code> (强制 单向): 将 p 的所有成员连接到 c; 忽略对齐</li>
<li><code>c :&lt;= p</code> (对齐): 将 p 的所有对齐的成员（非翻转的）连接到 c</li>
<li><code>c :&gt;= p</code> (翻转方向): 将 p 的所有非翻转的成员连接到 c</li>
<li><code>c :&lt;&gt;= p</code> (双向操作): 从 p 连接 c 的所有对齐的成员; 从 c 连接所有 p 的翻转的成员</li>
</ul>
<p>这些操作符可能看起来是符号的随机集合；然而，操作符之间的字符是一致的，每个操作符的语义描述如下：</p>
<ul>
<li>
<p><code>:</code> 表示消费者，或操作符的左侧。</p>
</li>
<li>
<p><code>=</code></p>
</li>
</ul>
<p>表示生产者，或操作符的右侧。</p>
<ul>
<li>
<p>因此, <code>c := p</code> 连接消费者（c）和生产者（p）</p>
</li>
<li>
<p><code>&lt;</code></p>
</li>
</ul>
<p>表示某些成员将驱动生产者到消费者，即从右到左。</p>
<ul>
<li>
<p>因此, <code>c :&lt;= p</code> 驱动生产者（p）的成员到消费者（c）的成员。</p>
</li>
<li>
<p>```</p>
<blockquote>
<p>```</p>
</blockquote>
</li>
</ul>
<p>表示一些信号将驱动消费者到生产者，即从左到右。</p>
<ul>
<li>因此, <code>c :&gt;= p</code> 驱动消费者（c）的成员到生产者（p）的成员。</li>
<li>
<p>因此, <code>c :&lt;&gt;= p</code> p 到 c 的成员和 c 到 p 的成员都驱动</p>
</li>
<li>
<p><code>#</code></p>
</li>
</ul>
<p>表示忽略成员对齐并驱动生产者到消费者。</p>
<ul>
<li>因此, <code>c :#= p</code> 将成员从 p 驱动到 c，忽略方向</li>
</ul>
<p>注意：此外，以 = 结尾的操作符具有赋值优先级，这意味着 x :&lt;&gt;= y + z 将转换为 x :&lt;&gt;= (y + z)，而不是 (x :&lt;&gt;= y ) + z。 &lt;&gt; 操作符并非如此，这对用户来说是一个小痛点。</p>
<h2 id="_27">对齐方式：翻转与对齐<a class="headerlink" href="#_27" title="Permanent link">&para;</a></h2>
<p>成员的对齐是一个相对属性：一个成员相对于同一组件或 Chisel 类型的另一个成员对齐/翻转。 因此，必须始终说明某个成员是否相对于该类型的另一个成员（父级、兄弟级、子级等）翻转/对齐。</p>
<p>我们使用以下非嵌套 bundle <code>Parent</code> 的示例来说明 <code>p</code> 成员之间的所有对齐关系。</p>
<div class="highlight"><pre><span></span><code>import chisel3._
class Parent extends Bundle {
  val alignedChild = UInt(32.W)
  val flippedChild = Flipped(UInt(32.W))
}
class MyModule0 extends Module {
  val p = Wire(new Parent)
}
</code></pre></div>
<p>首先，所有成员是与与他们自己对齐的：</p>
<ul>
<li><code>p</code> 和 w.r.t <code>p</code> 对齐</li>
<li><code>p.alignedChild</code> is aligned w.r.t <code>p.alignedChild</code></li>
<li><code>p.flippedChild</code> is aligned w.r.t <code>p.flippedChild</code></li>
</ul>
<p>接下来，我们列出所有的父/子关系。因为 <code>flippedChild</code> 是翻转的，它改变了它相对于 <code>Parent</code> 的对齐关系。</p>
<ul>
<li><code>p</code> is aligned w.r.t <code>p.alignedChild</code></li>
<li><code>p</code> is flipped w.r.t <code>p.flippedChild</code></li>
</ul>
<p>最后，我们可以列出所有的同级关系：</p>
<ul>
<li><code>p.alignedChild</code> is flipped w.r.t <code>p.flippedChild</code></li>
</ul>
<p>下一个例子有一个嵌套的 <code>GrandParent</code> bundle，它实例化了一个对齐的 <code>Parent</code> 和一个翻转的 <code>Parent</code>。</p>
<div class="highlight"><pre><span></span><code>import chisel3._
class GrandParent extends Bundle {
  val alignedParent = new Parent
  val flippedParent = Flipped(new Parent)
}
class MyModule1 extends Module {
  val g = Wire(new GrandParent)
}
</code></pre></div>
<p>考虑下面的祖父与孙辈的对齐关系。奇数次翻转表示翻转的关系；偶数次翻转表示对齐的关系。</p>
<ul>
<li><code>g</code> 与 w.r.t <code>g.flippedParent.flippedChild</code> 对齐</li>
<li><code>g</code> 与 w.r.t <code>g.alignedParent.alignedChild</code> 对齐</li>
<li><code>g</code> 与 w.r.t <code>g.flippedParent.alignedChild</code> 翻转</li>
<li><code>g</code> 与 w.r.t <code>g.alignedParent.flippedChild</code> 翻转</li>
</ul>
<p>考虑下面从 <code>g.alignedParent</code> 和 <code>g.flippedParent</code> 开始的对齐关系。注意无论 <code>g.alignedParent</code> 相对于 <code>g</code> 是对齐/翻转的，对于 <code>g.alignedParent</code> 和 <code>g.alignedParent.alignedChild</code> 之间的对齐关系没有影响，因为这个问题中对齐是只相对于两个成员的！：</p>
<ul>
<li><code>g.alignedParent</code> is aligned w.r.t. <code>g.alignedParent.alignedChild</code></li>
<li><code>g.flippedParent</code> is aligned w.r.t. <code>g.flippedParent.alignedChild</code></li>
<li><code>g.alignedParent</code> is flipped w.r.t. <code>g.alignedParent.flippedChild</code></li>
<li><code>g.flippedParent</code> is flipped w.r.t. <code>g.flippedParent.flippedChild</code></li>
</ul>
<p>总之，一个构件相对于硬件组件的另一个构件对齐或翻转。这意味着消费者/生产者的类型是确定任何操作符的行为所需的唯一信息。消费者/生产者是否是一个更大的 bundle 的成员是无关紧要的；你只需要知道消费者/生产者的类型。</p>
<h2 id="_28">输入/输出<a class="headerlink" href="#_28" title="Permanent link">&para;</a></h2>
<p><code>Input(gen)/Output(gen)</code> 是强制操作符。他们执行两个函数：（1）创建一个从所有子类型递归删除所有翻转的新的 Chisel type（仍然结构等价但对齐类型不再等价）。（2）如果是 <code>Input</code> 就使用 <code>Flipped</code>， 如果 <code>Output</code>，则保持对齐（不执行任何操作）。例如，如果我们想象一个名为 <code>cloneHiselTypeButStripAllFlips</code> 的函数，那么 <code>Input(gen)</code>在结构上和对齐类型等效于 <code>Flipped(cloneHisel TypeButStrip AllFlips(gen))</code>。</p>
<p>注意如果 <code>gen</code> 是 non-aggregate 的，则 <code>Input(nonAggregateGen)</code> 和 <code>Flipped(nonAggregateGen)</code>是等效的。</p>
<p>Future work will refactor how these primitives are exposed to the user to make Chisel’s type system more intuitive. See [<a href="https://github.com/chipsalliance/chisel3/issues/2643">https://github.com/chipsalliance/chisel3/issues/2643</a>].</p>
<p>了解了这些内容后，我们可以考虑下面的示例和成员的详细相对对齐：</p>
<p>首先，我们可以使用一个和 <code>Parent</code> 相似的例子但是用 <code>Input/Output</code> 代替 <code>Flipped</code>。因为 <code>alignedChild</code> 和 <code>flippedChild</code> 是 non-aggregates 的，<code>Input</code> 基本上只是一个 <code>Flipped</code>，因此对齐和之前的 <code>Parent</code> 示例相比没有变化。</p>
<div class="highlight"><pre><span></span><code>import chisel3._
class ParentWithOutputInput extends Bundle {
  val alignedCoerced = Output(UInt(32.W)) // Equivalent to just UInt(32.W)
  val flippedCoerced = Input(UInt(32.W))  // Equivalent to Flipped(UInt(32.W))
}
class MyModule2 extends Module {
  val p = Wire(new ParentWithOutputInput)
}
</code></pre></div>
<p>它的对齐关系和之前的 <code>Parent</code> 示例相同：</p>
<ul>
<li><code>p</code> 和 w.r.t <code>p</code> 是对齐的</li>
<li><code>p.alignedCoerced</code> 和 w.r.t <code>p.alignedCoerced</code> 是对齐的</li>
<li><code>p.flippedCoerced</code> 和 w.r.t <code>p.flippedCoerced</code> 是对齐的</li>
<li><code>p</code> 和 w.r.t <code>p.alignedCoerced</code> 是对齐的</li>
<li><code>p</code> 和 w.r.t <code>p.flippedCoerced</code> 是翻转的</li>
<li><code>p.alignedCoerced</code> 和 w.r.t <code>p.flippedCoerced</code> 是翻转的</li>
</ul>
<p>下一个示例有嵌套的 GrandParent bundle，它实例化了一个 <code>Output</code> <code>ParentWithOutputInput</code> 和一个 <code>Input</code> <code>ParentWithOutputInput</code>。</p>
<div class="highlight"><pre><span></span><code>import chisel3._
class GrandParentWithOutputInput extends Bundle {
  val alignedCoerced = Output(new ParentWithOutputInput)
  val flippedCoerced = Input(new ParentWithOutputInput)
}
class MyModule3 extends Module {
  val g = Wire(new GrandParentWithOutputInput)
}
</code></pre></div>
<p>记住 <code>Output(gen)/Input(gen)</code> 递归的删除了每一个子项的 <code>Flipped</code>。这使得 <code>gen</code> 的每一个成员和其他成员保持一致。</p>
<p>考虑以下祖父和孙辈之间的关系。因为 <code>alignedCoerced</code> 和 <code>flippedCorced</code> 与它们的所有递归成员对齐，所以它们是完全对齐的。因此，只有它们与 <code>g</code> 的对齐会影响孙辈的对齐：</p>
<p><code>g</code> 和 <code>g.alignedCoerced.alignedChild</code> 是对齐的
<code>g</code> 和 w.r.t <code>g.alignedCoerced.flippedChild</code> 是对齐的
<code>g</code> 和 w.r.t <code>g.flippedCoerced.alignedChild</code> 是对齐的
<code>g</code> 和 w.r.t <code>g.flippedCoerced.flippedChild</code> 是对齐的</p>
<p>考虑下面从 <code>g.alignedCoerced</code> 和 <code>g.flippedCoerced</code> 开始的对齐关系。注意无论 <code>g.alignedCoerced</code> 相对于 <code>g</code> 是对齐/翻转的，对于 <code>g.alignedCoerced</code> 和 <code>g.alignedCoerced.alignedChild</code> 或 <code>g.alignedCoerced.flippedChild</code> 之间的对齐关系没有影响，因为这个问题中对齐是只相对于两个成员的！然而，因为对齐是强制的，<code>g.alignedCoerced/g.flippedAligned</code> 和他们的子项的一切都是对其的：</p>
<p><code>g.alignedCoerced</code> 和 w.r.t. <code>g.alignedCoerced.alignedChild</code> 是对齐的。
<code>g.alignedCoerced</code> 和 w.r.t. <code>g.alignedCoerced.flippedChild</code> 是对齐的。
<code>g.flippedCoerced</code> 和 w.r.t. <code>g.flippedCoerced.alignedChild</code> 是对齐的。
<code>g.flippedCoerced</code> 和 w.r.t. <code>g.flippedCoerced.flippedChild</code> 是对齐的。</p>
<p>总的来说，<code>Input(gen)</code> 和 <code>Output(gen)</code> 递归的强制子类对齐, 并规定 <code>gen</code> 与其父项的 bundle 对齐（如果存在的话）。</p>
<h2 id="_29">使用完全对齐的成员连接组件<a class="headerlink" href="#_29" title="Permanent link">&para;</a></h2>
<h3 id="_30">单向连接操作符（:=）<a class="headerlink" href="#_30" title="Permanent link">&para;</a></h3>
<p>对于所有成员都对齐的简单链接，用 <code>:=</code>：</p>
<div class="highlight"><pre><span></span><code>import chisel3._
class FullyAlignedBundle extends Bundle {
  val a = Bool()
  val b = Bool()
}
class Example0 extends RawModule {
  val incoming = IO(Flipped(new FullyAlignedBundle))
  val outgoing = IO(new FullyAlignedBundle)
  outgoing := incoming
}
</code></pre></div>
<p>这会生成以下 Verilog，其中 <code>incoming</code> 的每个成员都会驱动 <code>outgoing</code> 的每个成员：</p>
<div class="highlight"><pre><span></span><code>// Generated by CIRCT firtool-1.44.0
module Example0(    // &lt;stdin&gt;:3:10
  input  incoming_a,    // connectable.md:86:20
         incoming_b,    // connectable.md:86:20
  output outgoing_a,    // connectable.md:87:20
         outgoing_b // connectable.md:87:20
);

  assign outgoing_a = incoming_a;   // &lt;stdin&gt;:3:10
  assign outgoing_b = incoming_b;   // &lt;stdin&gt;:3:10
endmodule
</code></pre></div>
<h2 id="_31">使用混合对齐的成员连接组件<a class="headerlink" href="#_31" title="Permanent link">&para;</a></h2>
<p>聚合 Chisel type 可以包括相对于彼此翻转的数据成员；在下面的示例中，<code>alignedChild</code> 和 <code>flippedChild</code> 相对于 <code>MixedAssignmentBundle</code> 对齐/翻转。</p>
<div class="highlight"><pre><span></span><code>import chisel3._
class MixedAlignmentBundle extends Bundle {
  val alignedChild = Bool()
  val flippedChild = Flipped(Bool())
}
</code></pre></div>
<p>因此，在两个 Chisel 组件之间存在许多所需的连接行为。首先，我们将介绍最常见的 Chisel 连接操作符 <code>:&lt;&gt;=</code>，用于连接具有混合排列成员的组件，然后花点时间研究端口方向和连接方向之间混淆的常见来源。然后，我们将探讨其余的 Chisel 连接操作符。</p>
<h3 id="_32">双向连接操作符（:&lt;&gt;=）<a class="headerlink" href="#_32" title="Permanent link">&para;</a></h3>
<p>对于需要“批量连接式语义”的连接，其中对齐的成员由生产者驱动到消费者，翻转的成员由消费者驱动到生产者，使用 <code>:&lt;&gt;=</code>。</p>
<div class="highlight"><pre><span></span><code>class Examplee1 extends RawModule {
  val incoming = IO(Flipped(new MixedAlignmentBundle))
  val outcoming = IO(new MixedAlignmentBundle)
  outgoing :&lt;&gt;= incoming
}
</code></pre></div>
<p>他会生成如下的 Verilog，对其的成员将 <code>incoming</code> 驱动到 <code>outcoming</code>，翻转的成员将 <code>outcoming</code> 驱动到 <code>incoming</code>：</p>
<div class="highlight"><pre><span></span><code>// Generated by CIRCT firtool-1.44.0
module Example1(    // &lt;stdin&gt;:3:10
  input  incoming_alignedChild, // connectable.md:114:20
         outgoing_flippedChild, // connectable.md:115:20
  output incoming_flippedChild, // connectable.md:114:20
         outgoing_alignedChild  // connectable.md:115:20
);

  assign incoming_flippedChild = outgoing_flippedChild; // &lt;stdin&gt;:3:10
  assign outgoing_alignedChild = incoming_alignedChild; // &lt;stdin&gt;:3:10
endmodule
</code></pre></div>
<h3 id="_33">端口方向计算与连接方向计算<a class="headerlink" href="#_33" title="Permanent link">&para;</a></h3>
<p>一个常见的问题是，如果使用混合对齐连接（例如<code>:&lt;&gt;=</code>）连接父组件的子成员，则子成员与其父组件的对齐会影响什么吗？答案是否定的，因为对齐总是相对于连接到的内容来计算的，并且成员总是与自己对齐。</p>
<p>在以下从 <code>incoming.alignedChild</code> 连接到 <code>outgoing.aligndChild</code> 的示例中，<code>incoming.lignedChild</code> 是否与<code>incoming</code> 对齐是无关紧要的，因为<code>:&lt;&gt;=</code> 仅计算相对于连接对象的对齐，而 <code>incoming.AlignedCild</code> 与 <code>incomingaligndCild</code> 对齐。</p>
<div class="highlight"><pre><span></span><code>class Example1a extends RawModule {
  val incoming = IO(Flipped(new MixedAlignmentBundle))
  val outgoing = IO(new MixedAlignmentBundle)
  outgoing.alignedChild :&lt;&gt;= incoming.alignedChild // whether incoming.alignedChild is aligned/flipped to incoming is IRRELEVANT to what gets connected with :&lt;&gt;=
}
</code></pre></div>
<p>虽然 <code>incoming.flicpedChild</code> 与 <code>incoming</code> 的对齐不会影响我们的操作符，但它确实会影响 <code>incoming.Flicpedchild</code> 是我的模块的输出端口还是输入端口。混淆的一个常见来源是将确定 <code>incoming.flicpedChild</code> 是否将解析为 verilog 输出/输入（端口方向计算）的过程与确定如何 <code>:&lt;&gt;=</code> 用什么驱动什么（连接方向计算）。虽然这两个过程都考虑了相对一致性，但它们是不同的。</p>
<p>端口方向计算始终计算相对于标有IO的组件的对齐。<code>IO(Flipped(gen))</code> 是一个传入端口，与 <code>gen</code> 对齐/翻转的 <code>gen</code> 的任何成员都是传入/传出端口。<code>IO(gen)</code>是传出端口，与 <code>gen</code> 对齐/翻转后的 <code>gen</code> 的任何成员都是传出/传入端口。</p>
<p>连接方向计算始终基于连接所引用的明确消费者/生产者来计算对齐。如果连接传入 <code>:&lt;&gt;=</code> 传出，则根据传入和传出计算对齐。如果连接 <code>incoming.alignedChild:&lt;&gt;=outgoing.alignedChild</code>，则根据 <code>incoming.liginedChild和outgoing.alignedChild</code> 计算对齐（<code>incoming</code> 与 <code>incoming-alignedChild</code> 的对齐无关）。</p>
<p>这意味着用户可以尝试连接到其模块的输入端口！如果我写 <code>x:&lt;&gt;=y</code>，并且 <code>x</code> 是当前模块的输入，那么这就是连接试图做的。然而，由于输入端口无法从当前模块中驱动，Chisel 将抛出错误。这与用户使用单向操作符时会遇到的错误相同：如果 <code>x</code> 是当前模块的输入，则 <code>x:=y</code> 将抛出相同的错误。组件是否可驱动与任何试图驱动它的连接操作符的语义无关。</p>
<p>总之，端口方向计算是相对于根标记 <code>IO</code> 的，但连接方向计算是关于连接正在进行的消费者/生产者的。这具有一个积极的特性，即连接语义仅基于 Chisel 结构类型及其消费者/生产者的相对对齐（没有更多，也没有更少）。</p>
<h3 id="_34">对齐连接操作符 (:&lt;=)<a class="headerlink" href="#_34" title="Permanent link">&para;</a></h3>
<p>对于需要“类批量连接语义”的对齐一半的连接，其中对齐的成员由生产者驱动到消费者，翻转的成员被忽略，请使用<code>:&lt;=</code>（对齐的连接）。</p>
<div class="highlight"><pre><span></span><code>class Example2 extends RawModule {
  val incoming = IO(Flipped(new MixedAlignmentBundle))
  val outgoing = IO(new MixedAlignmentBundle)
  incoming.flippedChild := DontCare // Otherwise FIRRTL throws an uninitialization error
  outgoing :&lt;= incoming
}
</code></pre></div>
<p>这会生成以下Verilog，其中对齐的成员将驱动 <code>incoming</code> 成员到 <code>outcoming</code> 成员，翻转的成员被忽略：</p>
<div class="highlight"><pre><span></span><code>// Generated by CIRCT firtool-1.44.0
module Example2(    // &lt;stdin&gt;:3:10
  input  incoming_alignedChild, // connectable.md:140:20
         outgoing_flippedChild, // connectable.md:141:20
  output incoming_flippedChild, // connectable.md:140:20
         outgoing_alignedChild  // connectable.md:141:20
);

  assign incoming_flippedChild = 1&#39;h0;  // &lt;stdin&gt;:3:10, connectable.md:142:25
  assign outgoing_alignedChild = incoming_alignedChild; // &lt;stdin&gt;:3:10
endmodule
</code></pre></div>
<h3 id="_35">翻转连接操作符（:&gt;=）<a class="headerlink" href="#_35" title="Permanent link">&para;</a></h3>
<p>对于需要“类批量连接语义”的翻转一半的连接，其中对齐的成员被忽略，翻转的成员被连接到消费者到生产者，请使用 <code>:&gt;=</code>（“翻转连接”或“背压连接”）。</p>
<div class="highlight"><pre><span></span><code>class Example3 extends RawModule {
  val incoming = IO(Flipped(new MixedAlignmentBundle))
  val outgoing = IO(new MixedAlignmentBundle)
  outgoing.alignedChild := DontCare // Otherwise FIRRTL throws an uninitialization error
  outgoing :&gt;= incoming
}
</code></pre></div>
<p>这会产生以下 verilog，在该 verilog 中，对齐成员被忽略，而翻转的成员被驱动到 <code>incoming</code>：</p>
<div class="highlight"><pre><span></span><code>// Generated by CIRCT firtool-1.44.0
module Example3(    // &lt;stdin&gt;:3:10
  input  incoming_alignedChild, // connectable.md:157:20
         outgoing_flippedChild, // connectable.md:158:20
  output incoming_flippedChild, // connectable.md:157:20
         outgoing_alignedChild  // connectable.md:158:20
);

  assign incoming_flippedChild = outgoing_flippedChild; // &lt;stdin&gt;:3:10
  assign outgoing_alignedChild = 1&#39;h0;  // &lt;stdin&gt;:3:10, connectable.md:159:25
endmodule
</code></pre></div>
<p>注意：精明的观察者将意识到语义上的 <code>c :&lt;&gt;= p</code> 完全等于 <code>c :&lt;= p</code>，然后是 <code>c :&gt;= p</code>。</p>
<h3 id="_36">强制单向连接操作符（:#=）<a class="headerlink" href="#_36" title="Permanent link">&para;</a></h3>
<p>对于你想要每个生产者成员始终驱动每个消费者成员的连接，无论对齐方式如何，请使用 <code>:#=</code>（“强制连接”）。该操作员可用于初始化包含混合对齐方式的类型的 <code>wire</code>。</p>
<div class="highlight"><pre><span></span><code>import chisel3.experimental.BundleLiterals._
class Example4 extends RawModule {
  val w = Wire(new MixedAlignmentBundle)
  dontTouch(w) // So we see it in the output verilog
  w :#= (new MixedAlignmentBundle).Lit(_.alignedChild -&gt; true.B, _.flippedChild -&gt; true.B)
}
</code></pre></div>
<p>这会产生以下 verilog，其中所有成员都从字面上驱动到 <code>w</code>，而不管有什么对齐方式：</p>
<div class="highlight"><pre><span></span><code>// Generated by CIRCT firtool-1.44.0
module Example4();  // &lt;stdin&gt;:8:10
  wire w_alignedChild = 1&#39;h1;   // connectable.md:177:15, :179:5
  wire w_flippedChild = 1&#39;h1;   // connectable.md:177:15, :179:5
endmodule
</code></pre></div>
<p>注意：精明的观察者将意识到语义上的 <code>c :#= P</code> 完全等于 <code>c :&lt;= p</code>，然后是<code>p :&gt;= c</code>（注意第二连接中的 <code>p</code> 和 <code>c</code> 切换位置）。</p>
<p>另一个用例 :#= 是将混合方向 Bundle 连接到完全对齐的 monitor。</p>
<div class="highlight"><pre><span></span><code>import chisel3.experimental.BundleLiterals._
class Example4b extends RawModule {
  val monitor = IO(Output(new MixedAlignmentBundle))
  val w = Wire(new MixedAlignmentBundle)
  dontTouch(w) // So we see it in the output verilog
  w :#= DontCare
  monitor :#= w
}
</code></pre></div>
<p>这会产生以下 verilog，其中所有成员都从字面上驱动到 <code>w</code>，湖库额对齐方式：</p>
<div class="highlight"><pre><span></span><code>// Generated by CIRCT firtool-1.44.0
module Example4b(   // &lt;stdin&gt;:8:10
  output monitor_alignedChild,  // connectable.md:196:19
         monitor_flippedChild   // connectable.md:196:19
);

  wire w_alignedChild = 1&#39;h0;   // connectable.md:197:15, :199:5
  wire w_flippedChild = 1&#39;h0;   // connectable.md:197:15, :199:5
  assign monitor_alignedChild = w_alignedChild; // &lt;stdin&gt;:8:10, connectable.md:197:15
  assign monitor_flippedChild = w_flippedChild; // &lt;stdin&gt;:8:10, connectable.md:197:15
endmodule
</code></pre></div>
<h2 id="connectable">Connectable<a class="headerlink" href="#connectable" title="Permanent link">&para;</a></h2>
<p>用户要连接不等效类型的 Chisel 组件并不少见。例如，用户可能想连接可能与字段相交的匿名 <code>Record</code> 组件，但不能连接，因为它们在结构上不是等效的。另外，一个人可能想要连接两种具有不同宽度的类型。</p>
<p>在这些情况下，<code>connectable</code> 是专业连接操作符行为的机制。对于未存在连接到的其他组件中或不匹配宽度的其他成员，或者对于始终将成员排除在连接的情况下，可以从可连接的对象中明确调用它们，而不是触发错误。</p>
<p>此外，还有其他技术可用于解决类似用例，包括 <code>.viewassupertype</code>，静态转换到超类（例如 <code>(x: T)</code>）或创建自定义数据范围。有关何时使用每种技术的讨论，会在之后讨论。</p>
<p>本节演示了如何在多种方案中专门使用 <code>connectable</code>。</p>
<h3 id="records">连接 Records<a class="headerlink" href="#records" title="Permanent link">&para;</a></h3>
<p>一个不常见的用途是尝试连接两个 Records。对于匹配的成员，应该连接它们，但是对于无与伦比的成员，由于无与伦比而引起的错误应被忽略。要实现这一目标，请使用其他操作员初始化所有记录成员，然后使用带有 <code>waiveAll</code> 的 <code>:&lt;&gt;=</code> 仅连接匹配成员。</p>
<p>注意，<code>.ViewAssuperType</code>，静态转换中没有任何一个自定义数据范围，因为 Scala 类型仍然是 <code>Record</code>。</p>
<div class="highlight"><pre><span></span><code>import scala.collection.immutable.SeqMap

class Example9 extends RawModule {
  val abType = new Record { val elements = SeqMap(&quot;a&quot; -&gt; Bool(), &quot;b&quot; -&gt; Flipped(Bool())) }
  val bcType = new Record { val elements = SeqMap(&quot;b&quot; -&gt; Flipped(Bool()), &quot;c&quot; -&gt; Bool()) }

  val p = IO(Flipped(abType))
  val c = IO(bcType)

  DontCare :&gt;= p
  c :&lt;= DontCare

  c.waive(_.elements(&quot;c&quot;)):&lt;&gt;= p.waive(_.elements(&quot;a&quot;))
}
</code></pre></div>
<p>这会产生以下 verilog，其中 <code>p.b</code> 是 <code>c.b</code> 驱动的：</p>
<div class="highlight"><pre><span></span><code>// Generated by CIRCT firtool-1.44.0
module Example9(    // &lt;stdin&gt;:3:10
  input  p_a,   // connectable.md:220:13
         c_b,   // connectable.md:221:13
  output p_b,   // connectable.md:220:13
         c_c    // connectable.md:221:13
);

  assign p_b = c_b; // &lt;stdin&gt;:3:10
  assign c_c = 1&#39;h0;    // &lt;stdin&gt;:3:10, connectable.md:224:5
endmodule
</code></pre></div>
<h3 id="waived">waived 连接的默认<a class="headerlink" href="#waived" title="Permanent link">&para;</a></h3>
<p>另一个不常见的用途是尝试连接两个 Records。对于匹配的成员，应该连接它们，但是对于不匹配的的成员，应将它们连接为默认值。要实现这一目标，请使用其他操作符初始化所有 Records 成员，然后使用带 <code>waiveAll</code> 的 <code>:&lt;&gt;=</code> 仅连接匹配成员。</p>
<div class="highlight"><pre><span></span><code>import scala.collection.immutable.SeqMap

class Example10 extends RawModule {
  val abType = new Record { val elements = SeqMap(&quot;a&quot; -&gt; Bool(), &quot;b&quot; -&gt; Flipped(Bool())) }
  val bcType = new Record { val elements = SeqMap(&quot;b&quot; -&gt; Flipped(Bool()), &quot;c&quot; -&gt; Bool()) }

  val p = Wire(abType)
  val c = Wire(bcType)

  dontTouch(p) // So it doesn&#39;t get constant-propped away for the example
  dontTouch(c) // So it doesn&#39;t get constant-propped away for the example

  p :#= abType.Lit(_.elements(&quot;a&quot;) -&gt; true.B, _.elements(&quot;b&quot;) -&gt; true.B)
  c :#= bcType.Lit(_.elements(&quot;b&quot;) -&gt; true.B, _.elements(&quot;c&quot;) -&gt; true.B)

  c.waive(_.elements(&quot;c&quot;)) :&lt;&gt;= p.waive(_.elements(&quot;a&quot;))
}
</code></pre></div>
<p>这会生成以下 Verilog，其中 <code>p.b</code> 是从 <code>c.b</code> 驱动的，并且 <code>p.a</code>, <code>c.b</code> 和 <code>c.c</code> 被初始化为默认值：</p>
<div class="highlight"><pre><span></span><code>// Generated by CIRCT firtool-1.44.0
module Example10(); // &lt;stdin&gt;:12:10
  wire p_a = 1&#39;h1;  // connectable.md:246:15, :252:5
  wire c_c = 1&#39;h1;  // connectable.md:247:15, :252:5
  wire c_b = 1&#39;h1;  // connectable.md:247:15, :252:5
  wire p_b = c_b;   // connectable.md:246:15, :247:15
endmodule
</code></pre></div>
<h3 id="_37">与可选成员连接类型<a class="headerlink" href="#_37" title="Permanent link">&para;</a></h3>
<p>在下面的示例中，我们可以使用 <code>:&lt;&gt;=</code> 和 <code>waive</code> 来连接两个 <code>MyDecoupledOpts</code>，其中只有一个具有 <code>bits</code> 成员。</p>
<div class="highlight"><pre><span></span><code>class MyDecoupledOpt(hasBits: Boolean) extends Bundle {
  val valid = Bool()
  val ready = Flipped(Bool())
  val bits = if (hasBits) Some(UInt(32.W)) else None
}
class Example6 extends RawModule {
  val in  = IO(Flipped(new MyDecoupledOpt(true)))
  val out = IO(new MyDecoupledOpt(false))
  out :&lt;&gt;= in.waive(_.bits.get) // We can know to call .get because we can inspect in.bits.isEmpty
}
</code></pre></div>
<p>这会生成以下 verilog，即 <code>ready</code> 和 <code>valid</code> 被连接起来，并且忽略了 <code>bits</code>：</p>
<div class="highlight"><pre><span></span><code>// Generated by CIRCT firtool-1.44.0
module Example6(    // &lt;stdin&gt;:3:10
  input         in_valid,   // connectable.md:276:15
  input  [31:0] in_bits,    // connectable.md:276:15
  input         out_ready,  // connectable.md:277:15
  output        in_ready,   // connectable.md:276:15
                out_valid   // connectable.md:277:15
);

  assign in_ready = out_ready;  // &lt;stdin&gt;:3:10
  assign out_valid = in_valid;  // &lt;stdin&gt;:3:10
endmodule
</code></pre></div>
<h3 id="_38">总是忽略由额外成员（部分连接操作符）造成的错误<a class="headerlink" href="#_38" title="Permanent link">&para;</a></h3>
<p>最不安全的连接是仅连接消费者和生产者中存在的成员，并忽略所有其他成员。这是不安全的，因为此连接永远不会在任何 Chisel 类型上出错。</p>
<p>做到这一点，你可以使用 <code>.waiveAll</code> 和静态转换到 <code>Data</code>：</p>
<div class="highlight"><pre><span></span><code>class OnlyA extends Bundle {
  val a = UInt(32.W)
}
class OnlyB extends Bundle {
  val b = UInt(32.W)
}
class Example11 extends RawModule {
  val in  = IO(Flipped(new OnlyA))
  val out = IO(new OnlyB)

  out := DontCare

  (out: Data).waiveAll :&lt;&gt;= (in: Data).waiveAll
}
</code></pre></div>
<p>这会生成如下 verilog，没有任何东西被连接起来：</p>
<div class="highlight"><pre><span></span><code>// Generated by CIRCT firtool-1.44.0
module Example11(   // &lt;stdin&gt;:3:10
  input  [31:0] in_a,   // connectable.md:302:15
  output [31:0] out_b   // connectable.md:303:15
);

  assign out_b = 32&#39;h0; // &lt;stdin&gt;:3:10, connectable.md:305:7
endmodule
</code></pre></div>
<h3 id="_39">连接不同位宽的组件<a class="headerlink" href="#_39" title="Permanent link">&para;</a></h3>
<p>如果宽度较大的组件连接到宽度较小的组件，则不可连接的操作符会隐式截断。可连接的操作符不允许这种隐式截断行为，并要求被驱动的组件与源组件的宽度相等或更大。</p>
<p>如果希望隐式截断的行为发生，<code>connectable</code> 操作符提供了一种 <code>squeeze</code> 机制，该机制将使连接能够继续并隐式截断。</p>
<div class="highlight"><pre><span></span><code>import scala.collection.immutable.SeqMap

class Example14 extends RawModule {
  val p = IO(Flipped(UInt(4.W)))
  val c = IO(UInt(3.W))

  c :&lt;&gt;= p.squeeze
}
</code></pre></div>
<p>这会生成以下 verilog，其中 <code>p</code> 在驱动 <code>c</code> 之前被隐式截断：</p>
<div class="highlight"><pre><span></span><code>// Generated by CIRCT firtool-1.44.0
module Example14(   // &lt;stdin&gt;:3:10
  input  [3:0] p,   // connectable.md:324:13
  output [2:0] c    // connectable.md:325:13
);

  assign c = p[2:0];    // &lt;stdin&gt;:3:10, connectable.md:327:5
endmodule
</code></pre></div>
<h3 id="_40">在可连接的任何操作符中排除任何成员<a class="headerlink" href="#_40" title="Permanent link">&para;</a></h3>
<p>如果用户想始终将字段从连接中排除，请使用永远不会连接字段的 <code>exclude</code> 机制（好像它不存在连接）。</p>
<p>请注意，如果一个字段匹配生产者和消费者，但仅排除了一个字段，则另一个非排除的字段仍然会触发错误。要解决此问题，请使用 <code>waive</code> 或 <code>exclude</code>。</p>
<div class="highlight"><pre><span></span><code>import scala.collection.immutable.SeqMap

class BundleWithSpecialField extends Bundle {
  val foo = UInt(3.W)
  val special = Bool()
}
class Example15 extends RawModule {
  val p = IO(Flipped(new BundleWithSpecialField()))
  val c = IO(new BundleWithSpecialField())

  c.special := true.B // must initialize it

  c.exclude(_.special) :&lt;&gt;= p.exclude(_.special)
}
</code></pre></div>
<p>这会生成以下verilog，其中 <code>special</code> 字段未连接：</p>
<div class="highlight"><pre><span></span><code>// Generated by CIRCT firtool-1.44.0
module Example15(   // &lt;stdin&gt;:3:10
  input  [2:0] p_foo,   // connectable.md:350:13
  input        p_special,   // connectable.md:350:13
  output [2:0] c_foo,   // connectable.md:351:13
  output       c_special    // connectable.md:351:13
);

  assign c_foo = p_foo; // &lt;stdin&gt;:3:10
  assign c_special = 1&#39;h1;  // &lt;stdin&gt;:3:10, connectable.md:353:13
endmodule
</code></pre></div>
<h3 id="chisel">连接结构上不相等的 Chisel 类型的技术<a class="headerlink" href="#chisel" title="Permanent link">&para;</a></h3>
<p><code>Dataview</code> 和 <code>ViewAssuperType</code> 创建具有不同 Chisel 类型的组件的 view。这意味着用户可以首先创建消费者或生产者（或两者）的 <code>Dataview</code>，以便 Chisel 类型在结构上等效。当消费者和生产商之间的差异不是超级嵌套时，并且如果他们具有编码其结构的丰富类型时，这很有用。通常，<code>Dataview</code> 是使用的首选机制（如果可以的话），因为它在 Scala 类型中保留了最多的 Chisel 信息，但是在许多情况下，它不起作用，因此必须退回 <code>Connectable</code>。</p>
<p><code>Connectable</code> 不会更改 Chisel 类型，而是将悬挂或无连接的成员的操作符语义更改来避免错误。这对于当消费者和生产者之间的差异不显示在 Scala 类型系统中（例如类型 Option[Data] 的当前/缺失字段或匿名 <code>Record</code>）或深深地嵌套在一个特别繁重的捆绑包中时，创建 <code>Dataview</code>。</p>
<p>静态转换（例如<code>(x: T)</code>）允许连接具有不同类型的组件，但使 Chisel 类型保持不变。即使 Scala 类型不同，也要使用它来强迫连接发生。</p>
<p>人们可能想知道，如果操作符可以很容易被绕过，为什么它们首先需要相同的 Scala 类型。原因是鼓励用户使用 Scala 类型系统来编码Chisel 信息，因为它可以使他们的代码更加健壮；然而，我们不想对此采取严厉措施，因为有时我们想让用户“just connect the darn thing”。</p>
<p>当所有其他方法都失败时，人们总是可以手动扩展连接以逐个成员执行他们想要发生的事情。这种方法的缺点是其冗长，并且向组件添加新成员将需要更新手动连接。</p>
<p>关于 <code>Connectable</code> 与 <code>viewAsSupertype/DataView</code> 与静态转换（例如 <code>(x: T)</code>）需要记住的事项：</p>
<ul>
<li><code>DataView</code> 和 <code>viewAsSupertype</code> 将抢先删除具有不同 Chisel 类型的新视图中不存在的成员，因此 <code>DataView</code> 确实会影响连接的内容</li>
<li><code>Connectable</code> 可用于免除最终悬空或未连接的成员的错误。 重要的是，<code>Connectable</code> waives 不会影响已连接的内容</li>
<li>静态转换不会删除额外的成员，因此静态转换不会影响连接的内容</li>
</ul>
<h2 id="_41">使用冲突的名称连接同一超类的不同子类<a class="headerlink" href="#_41" title="Permanent link">&para;</a></h2>
<p>在这些示例中，我们将 <code>MyDecoupled</code> 与 <code>MyDecoupledOtherBits</code> 连接。两者都是 <code>MyReadyValid</code> 的子类型，并且都有 <code>UInt(32.W)</code> 的位字段。</p>
<p>第一个示例将使用 <code>.viewAsSupertype</code> 将它们连接为 <code>MyReadyValid</code>。 由于它更改了 <code>Chisel</code> 类型以省略两个 <code>bits</code> 字段，因此 <code>bits</code> 字段未连接。</p>
<div class="highlight"><pre><span></span><code>import experimental.dataview._
class MyDecoupledOtherBits extends MyReadyValid {
  val bits = UInt(32.W)
}
class Example12 extends RawModule {
  val in  = IO(Flipped(new MyDecoupled))
  val out = IO(new MyDecoupledOtherBits)

  out := DontCare

  out.viewAsSupertype(new MyReadyValid) :&lt;&gt;= in.viewAsSupertype(new MyReadyValid)
}
</code></pre></div>
<p>注意 <code>bits</code> 字段是未连接的。</p>
<div class="highlight"><pre><span></span><code>// Generated by CIRCT firtool-1.44.0
module Example12(   // &lt;stdin&gt;:3:10
  input         in_valid,   // connectable.md:377:15
  input  [31:0] in_bits,    // connectable.md:377:15
  input         out_ready,  // connectable.md:378:15
  output        in_ready,   // connectable.md:377:15
                out_valid,  // connectable.md:378:15
  output [31:0] out_bits    // connectable.md:378:15
);

  assign in_ready = out_ready;  // &lt;stdin&gt;:3:10
  assign out_valid = in_valid;  // &lt;stdin&gt;:3:10
  assign out_bits = 32&#39;h0;  // &lt;stdin&gt;:3:10, connectable.md:380:7
endmodule
</code></pre></div>
<p>第二个示例将使用静态转换和 <code>.waive(_.bits)</code> 将它们连接为 <code>MyReadyValid</code>。 请注意，由于静态转换不会更改 Chisel 类型，因此连接会发现消费者和生产者都有一个 <code>bits</code> 字段。 这意味着，由于它们在结构上是等效的，因此它们匹配并连接。 <code>waive(_.bits)</code> 不执行任何操作，因为这些位不是悬空的，也不是未连接的。</p>
<div class="highlight"><pre><span></span><code>import experimental.dataview._
class Example13 extends RawModule {
  val in  = IO(Flipped(new MyDecoupled))
  val out = IO(new MyDecoupledOtherBits)

  out := DontCare

  out.waiveAs[MyReadyValid](_.bits) :&lt;&gt;= in.waiveAs[MyReadyValid](_.bits)
}
</code></pre></div>
<p>请注意，<code>bits</code> 字段是连接的，即使它们被放弃，因为放弃只是改变如果它们丢失则是否应该抛出错误，而不是如果它们在结构上等效则不连接它们。 要始终忽略连接，请在一侧使用 <code>exclude</code>，并在另一侧使用 <code>exclude</code> 或 <code>waive</code>。</p>
<div class="highlight"><pre><span></span><code>// Generated by CIRCT firtool-1.44.0
module Example13(   // &lt;stdin&gt;:3:10
  input         in_valid,   // connectable.md:399:15
  input  [31:0] in_bits,    // connectable.md:399:15
  input         out_ready,  // connectable.md:400:15
  output        in_ready,   // connectable.md:399:15
                out_valid,  // connectable.md:400:15
  output [31:0] out_bits    // connectable.md:400:15
);

  assign in_ready = out_ready;  // &lt;stdin&gt;:3:10
  assign out_valid = in_valid;  // &lt;stdin&gt;:3:10
  assign out_bits = in_bits;    // &lt;stdin&gt;:3:10
endmodule
</code></pre></div>
<h3 id="_42">通过忽略多余的成员将子类与超类连接<a class="headerlink" href="#_42" title="Permanent link">&para;</a></h3>
<p>注意这个例子，使用 <code>.viewAsSupertype</code> 会更好。</p>
<p>在接下来的示例中，我们可以使用 <code>:&lt;&gt;=</code> 通过放弃 <code>bits</code> 成员把 <code>MyReadyValid</code> 连接到 <code>MyDecoupled</code>。</p>
<div class="highlight"><pre><span></span><code>class MyReadyValid extends Bundle {
  val valid = Bool()
  val ready = Flipped(Bool())
}
class MyDecoupled extends MyReadyValid {
  val bits = UInt(32.W)
}
class Example5 extends RawModule {
  val in  = IO(Flipped(new MyDecoupled))
  val out = IO(new MyReadyValid)
  out :&lt;&gt;= in.waiveAs[MyReadyValid](_.bits)
}
</code></pre></div>
<p>这个例子生成了下面的 verilog, <code>ready</code> 和 <code>valid</code> 是连接的, 然后 <code>bits</code> 被忽略了:</p>
<div class="highlight"><pre><span></span><code>// Generated by CIRCT firtool-1.44.0
module Example5(    // &lt;stdin&gt;:3:10
  input         in_valid,   // connectable.md:429:15
  input  [31:0] in_bits,    // connectable.md:429:15
  input         out_ready,  // connectable.md:430:15
  output        in_ready,   // connectable.md:429:15
                out_valid   // connectable.md:430:15
);

  assign in_ready = out_ready;  // &lt;stdin&gt;:3:10
  assign out_valid = in_valid;  // &lt;stdin&gt;:3:10
endmodule
</code></pre></div>
<h3 id="_43">连接不同的子类<a class="headerlink" href="#_43" title="Permanent link">&para;</a></h3>
<p>注意这个例子，使用 <code>.viewAsSupertype</code> 会更好。</p>
<p>请注意，连接操作符要求消费者和生产商是相同的 Scala 类型，以鼓励静态捕获更多信息，但是在连接之前，它们始终可以将其转换到 <code>Data</code> 或其他常见的超类。</p>
<p>在下面的示例中，我们可以使用 <code>:&lt;&gt;=</code> 和 <code>waiveAs</code> 来连接 <code>MyReadyValid</code> 的两个不同的子类。</p>
<div class="highlight"><pre><span></span><code>class HasBits extends MyReadyValid {
  val bits = UInt(32.W)
}
class HasEcho extends MyReadyValid {
  val echo = Flipped(UInt(32.W))
}
class Example7 extends RawModule {
  val in  = IO(Flipped(new HasBits))
  val out = IO(new HasEcho)
  out.waiveAs[MyReadyValid](_.echo) :&lt;&gt;= in.waiveAs[MyReadyValid](_.bits)
}
</code></pre></div>
<p>这个例子生成了下面的 verilog, <code>ready</code> 和 <code>valid</code> 是连接的, 然后 <code>bits</code> 和 <code>echo</code> 被忽略了:</p>
<div class="highlight"><pre><span></span><code>// Generated by CIRCT firtool-1.44.0
module Example7(    // &lt;stdin&gt;:3:10
  input         in_valid,   // connectable.md:455:15
  input  [31:0] in_bits,    // connectable.md:455:15
  input         out_ready,  // connectable.md:456:15
  input  [31:0] out_echo,   // connectable.md:456:15
  output        in_ready,   // connectable.md:455:15
                out_valid   // connectable.md:456:15
);

  assign in_ready = out_ready;  // &lt;stdin&gt;:3:10
  assign out_valid = in_valid;  // &lt;stdin&gt;:3:10
endmodule
</code></pre></div>
<h2 id="faq">FAQ<a class="headerlink" href="#faq" title="Permanent link">&para;</a></h2>
<p>我如何尽可能灵活地连接两个项目（尽你所能，但永远不要出错）</p>
<p>用 <code>.unsafe</code>。</p>
<div class="highlight"><pre><span></span><code>class ExampleUnsafe extends RawModule {
  val in  = IO(Flipped(new Bundle { val foo = Bool(); val bar = Bool() }))
  val out = IO(new Bundle { val baz = Bool(); val bar = Bool() })
  out.unsafe :&lt;&gt;= in.unsafe // bar is connected, and nothing errors
}
</code></pre></div>
<p>如何连接两个项，但不关心 scala 类型是否等效？</p>
<p>用 <code>.as</code>。</p>
<div class="highlight"><pre><span></span><code>class ExampleAs extends RawModule {
  val in  = IO(Flipped(new Bundle { val foo = Bool(); val bar = Bool() }))
  val out = IO(new Bundle { val foo = Bool(); val bar = Bool() })
  // foo and bar are connected, although Scala types aren&#39;t the same
  out.as[Data] :&lt;&gt;= in.as[Data]
}
</code></pre></div>
<h1 id="decoders">译码器（Decoders）<a class="headerlink" href="#decoders" title="Permanent link">&para;</a></h1>
<p>在复杂的设计中，通常会从来自数据总线的大 <code>UInt</code> 中识别某些模式，并根据这种观察将操作分派到下一个管道阶段。 执行此操作的电路可称为“译码器”，例如总线交叉开关中的地址解码器或 CPU 前端中的指令解码器。 Chisel 提供了一些实用程序类来在 <code>util.exprimental.decode</code> 包中生成它们。</p>
<h2 id="_44">基本译码器<a class="headerlink" href="#_44" title="Permanent link">&para;</a></h2>
<p><code>decoder</code> 提供的最简单的 API 本质上只是一个编码了你期望的输入和输出的真值表。</p>
<div class="highlight"><pre><span></span><code>import chisel3._
import chisel3.util.BitPat
import chisel3.util.experimental.decode._

class SimpleDecoder extends Module {
  val table = TruthTable(
    Map(
      BitPat(&quot;b001&quot;) -&gt; BitPat(&quot;b?&quot;),
      BitPat(&quot;b010&quot;) -&gt; BitPat(&quot;b?&quot;),
      BitPat(&quot;b100&quot;) -&gt; BitPat(&quot;b1&quot;),
      BitPat(&quot;b101&quot;) -&gt; BitPat(&quot;b1&quot;),
      BitPat(&quot;b111&quot;) -&gt; BitPat(&quot;b1&quot;)
    ),
    BitPat(&quot;b0&quot;))
  val input = IO(Input(UInt(3.W)))
  val output = IO(Output(UInt(1.W)))
  output := decoder(input, table)
}
</code></pre></div>
<h2 id="decodertable">DecoderTable<a class="headerlink" href="#decodertable" title="Permanent link">&para;</a></h2>
<p>当译码结果包含多个字段，每个字段有自己的含义时，真值表很快就变得难以维护起来。<code>DecoderTable1</code> API 被设计出来用结构化的定义来生成译码表。</p>
<p><code>DecodePattern</code> trait 是结构化信息和它的编码之间的桥梁。成员 <code>bitPat</code> 定义了译码真值表的输入 <code>BitPat</code>，其他的成员可以被定义来包含一些结构信息。</p>
<p>为了生成输出一侧的译码真值表，要使用 <code>DecodeField</code> trait。给定一个 <code>DecodePattern</code> 对象的实现，<code>genTable</code> 方法会返回需要的输出。</p>
<div class="highlight"><pre><span></span><code>import chisel3.util.BitPat
import chisel3.util.experimental.decode._

case class Pattern(val name: String, val code: BigInt) extends DecodePattern {
  def bitPat: BitPat = BitPat(&quot;b&quot; + code.toString(2))
}

object NameContainsAdd extends BoolDecodeField[Pattern] {
  def name = &quot;name contains &#39;add&#39;&quot;
  def genTable(i: Pattern) = if (i.name.contains(&quot;add&quot;)) y else n
}
</code></pre></div>
<p>然后，所有的 <code>DecodePattern</code> 案例都可以生成或从外部源读取。使用所有的 <code>DecodeField</code> 对象，可以很容易地生成解码器，并通过相应的 <code>DecodeFields</code> 读取输出。</p>
<div class="highlight"><pre><span></span><code>import chisel3._
import chisel3.util.experimental.decode._

class SimpleDecodeTable extends Module {
  val allPossibleInputs = Seq(Pattern(&quot;addi&quot;, BigInt(&quot;0x2&quot;)) /* can be generated */)
  val decodeTable = new DecodeTable(allPossibleInputs, Seq(NameContainsAdd))

  val input = IO(Input(UInt(4.W)))
  val isAddType = IO(Output(Bool()))
  val decodeResult = decodeTable.decode(input)
  isAddType := decodeResult(NameContainsAdd)
}
</code></pre></div>
<h1 id="intrinsics">Intrinsics<a class="headerlink" href="#intrinsics" title="Permanent link">&para;</a></h1>
<p>Chisel Intrinsics 用于实例化实现定义功能。Intrinsics 为特定编译器提供了一种以库代码无法实现的方式扩展语言功能的方法。</p>
<p>定义为 <code>IntrinicModule</code> 的模块将被实例化为正常模块，但是 Intrinsics 字段将通信与编译器通信用于实现模块的哪种功能。实现可能不是实际模块，内在的模块性质仅用于实例化目的。</p>
<p>Intrinsics 的实现将被打字检查。实现记录了 Intrinsics 什么可用。</p>
<h2 id="_45">参数化<a class="headerlink" href="#_45" title="Permanent link">&para;</a></h2>
<p>参数可以作为参数传递给 <code>IntModule</code> 构造函数。</p>
<h2 id="example">Example<a class="headerlink" href="#example" title="Permanent link">&para;</a></h2>
<p>以下为“Other Intrinsic”创建了一个 Intrinsic 模块。它采用一个名为“STRING”的参数，并具有多个端口。</p>
<div class="highlight"><pre><span></span><code>import chisel3.experimental.IntrinsicModule

class ExampleIntrinsicModule(str: String) extends IntrinsicModule(
  &quot;OtherIntrinsic&quot;,
  Map(&quot;STRING&quot; -&gt; str)) {
  val foo = IO(new Bundle() {
    val in = Input(UInt())
    val out = Output(UInt(32.W))
  })
}
</code></pre></div>
<h1 id="annotations">Annotations<a class="headerlink" href="#annotations" title="Permanent link">&para;</a></h1>
<p><code>Annotation</code> 是与 FIRRTL 电路中零个或多个“事物”相关联的元数据容器。 通常，<code>Annotation</code> 用于将信息从 Chisel 传递到特定的已知 FIRRTL <code>transform</code>。 通过这种方式，注释可以被视为特定 <code>Transform</code> 消耗的“参数”。</p>
<p><code>Annotation</code> 旨在成为 Chisel 的实现细节，而不是由用户手动构建或直接交互。 相反，它们旨在通过现有或新的 Chisel API 来使用。 例如，<code>dontTouch</code> API 为用户提供了一种指示不应优化线路或端口的方法。 该 API 由 <code>DontTouchAnnotation</code> 支持，但这对 Chisel 用户是隐藏的。</p>
<p>所有支持的 <code>Annotation</code> 的列表作为 <a href="https://circt.llvm.org/docs/Dialects/FIRRTL/FIRRTLAnnotations">circt.llvm.org 上 FIRRTL 文档的一部分</a>进行维护。</p>
<h1 id="source-locators">源定位器（Source Locators）<a class="headerlink" href="#source-locators" title="Permanent link">&para;</a></h1>
<p>详细阐述 Chisel 设计并发出 FIRRTL 文件或 Verilog 文件时，Chisel 将自动添加源定位器，这些定位器将其引用到包含相应的 Chisel 代码的 Scala 文件。</p>
<p>在 FIRRTL 文件中，看上去像是：</p>
<div class="highlight"><pre><span></span><code>wire w : UInt&lt;3&gt; @[src/main/scala/MyProject/MyFile.scala 1210:21]
</code></pre></div>
<p>在 Verilog 文件中，看上去像是：</p>
<div class="highlight"><pre><span></span><code>wire [2:0] w; // @[src/main/scala/MyProject/MyFile.scala 1210:21]
</code></pre></div>
<p>默认情况下，包含调用 JVM 的文件的相对路径。 要更改相对路径的计算位置，请设置 Java 系统属性 <code>-Dchisel.project.root=/absolute/path/to/root</code>。 该选项可以直接传递给 <code>sbt (sbt -Dchisel.project.root=/absolute/path/to/root)</code>。 在 <code>build.sbt</code> 文件中设置值将不起作用，因为它需要传递给调用 <code>sbt</code> 的 JVM（而不是相反）。 我们预计这仅与可能需要更多定制的发布版本相关。</p>
<h1 id="_46">深入了解连接操作符<a class="headerlink" href="#_46" title="Permanent link">&para;</a></h1>
<p>Chisel 包含两个连接运算符 <code>:=</code> 和 <code>&lt;&gt;</code>。本文档对两者的差异以及何时使用其中一个或另一个进行了更深入的解释。使用 <code>DecoupledIO</code> 的 Scastie 实例的实验证明了这些差异。</p>
<h2 id="_47">实验设置<a class="headerlink" href="#_47" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code>// Imports used by the following examples
import chisel3._
import chisel3.util.DecoupledIO
import circt.stage.ChiselStage
</code></pre></div>
<p>实验的图表可以在<a href="https://docs.google.com/document/d/14C918Hdahk2xOGSJJBT-ZVqAx99_hg3JQIq-vaaifQU/edit?usp=sharing">这里</a>查看。</p>
<p><img alt="img" src="./Chisel 3 说明文档翻译 _ Light Blog_files/connection-operators-experiment.svg" /></p>
<div class="highlight"><pre><span></span><code>class Wrapper extends Module{
  val io = IO(new Bundle {
  val in = Flipped(DecoupledIO(UInt(8.W)))
  val out = DecoupledIO(UInt(8.W))
  })
  val p = Module(new PipelineStage)
  val c = Module(new PipelineStage)
  // connect Producer to IO
  p.io.a &lt;&gt; io.in
  // connect producer to consumer
  c.io.a &lt;&gt; p.io.b
  // connect consumer to IO
  io.out &lt;&gt; c.io.b
}
class PipelineStage extends Module{
  val io = IO(new Bundle{
    val a = Flipped(DecoupledIO(UInt(8.W)))
    val b = DecoupledIO(UInt(8.W))
  })
  io.b &lt;&gt; io.a
}
</code></pre></div>
<p>下面我们可以看到这个例子的 Verilog 结果：</p>
<div class="highlight"><pre><span></span><code>ChiselStage.emitSystemVerilog(new Wrapper)
// res0: String = &quot;&quot;&quot;// Generated by CIRCT firtool-1.44.0
// module PipelineStage(    // &lt;stdin&gt;:3:10, :10:10
//   input        io_a_valid,   // connection-operators.md:37:14
//   input  [7:0] io_a_bits,    // connection-operators.md:37:14
//   input        io_b_ready,   // connection-operators.md:37:14
//   output       io_a_ready,   // connection-operators.md:37:14
//                io_b_valid,   // connection-operators.md:37:14
//   output [7:0] io_b_bits // connection-operators.md:37:14
// );
// 
//   assign io_a_ready = io_b_ready;    // &lt;stdin&gt;:3:10, :10:10
//   assign io_b_valid = io_a_valid;    // &lt;stdin&gt;:3:10, :10:10
//   assign io_b_bits = io_a_bits;  // &lt;stdin&gt;:3:10, :10:10
// endmodule
// 
// module Wrapper(  // &lt;stdin&gt;:17:10
//   input        clock,    // &lt;stdin&gt;:18:11
//                reset,    // &lt;stdin&gt;:19:11
//                io_in_valid,  // connection-operators.md:21:14
//   input  [7:0] io_in_bits,   // connection-operators.md:21:14
//   input        io_out_ready, // connection-operators.md:21:14
//   output       io_in_ready,  // connection-operators.md:21:14
//                io_out_valid, // connection-operators.md:21:14
//   output [7:0] io_out_bits   // connection-operators.md:21:14
// );
// 
//   wire       _c_io_a_ready;  // connection-operators.md:26:17
//   wire       _p_io_b_valid;  // connection-operators.md:25:17
//   wire [7:0] _p_io_b_bits;   // connection-operators.md:25:17
//   PipelineStage p (  // connection-operators.md:25:17
//     .io_a_valid (io_in_valid),
//     .io_a_bits  (io_in_bits),
//     .io_b_ready (_c_io_a_ready), // connection-operators.md:26:17
//     .io_a_ready (io_in_ready),
//     .io_b_valid (_p_io_b_valid),
//     .io_b_bits  (_p_io_b_bits)
//   );
//   PipelineStage c (  // connection-operators.md:26:17
//     .io_a_valid (_p_io_b_valid), // connection-operators.md:25:17
//     .io_a_bits  (_p_io_b_bits),  // connection-operators.md:25:17
//     .io_b_ready (io_out_ready),
//     .io_a_ready (_c_io_a_ready),
//     .io_b_valid (io_out_valid),
//     .io_b_bits  (io_out_bits)
//   );
// endmodule
// 
// &quot;&quot;&quot;
</code></pre></div>
<h2 id="1">概念 1：&lt;&gt; 是可交换的<a class="headerlink" href="#1" title="Permanent link">&para;</a></h2>
<p>本实验是利用上述实验来测试 <code>&lt;&gt;</code> 的功能。</p>
<p>实现这一点需要翻转 <code>&lt;&gt;</code> 运算符的 RHS 和 LHS，并查看 <code>&lt;&gt;</code> 将如何反应。（实验的 Scastie 链接：<a href="https://scastie.scala-lang.org/Shorla/LVhlbkFQQnq7X3trHfgZZQ">https://scastie.scala-lang.org/Shorla/LVhlbkFQQnq7X3trHfgZZQ</a>）</p>
<div class="highlight"><pre><span></span><code>import chisel3._
import chisel3.util.DecoupledIO
import circt.stage.ChiselStage

class Wrapper extends Module{
  val io = IO(new Bundle {
  val in = Flipped(DecoupledIO(UInt(8.W)))
  val out = DecoupledIO(UInt(8.W))
  })
  val p = Module(new PipelineStage)
  val c = Module(new PipelineStage)
  // connect producer to I/O
  io.in &lt;&gt; p.io.a
  // connect producer  to consumer
  p.io.b &lt;&gt; c.io.a
  // connect consumer to I/O
  c.io.b &lt;&gt; io.out
}
class PipelineStage extends Module{
  val io = IO(new Bundle{
    val a = Flipped(DecoupledIO(UInt(8.W)))
    val b = DecoupledIO(UInt(8.W))
  })
  io.a &lt;&gt; io.b
</code></pre></div>
<p>下面我们可以看到这个例子的 Verilog 结果：</p>
<div class="highlight"><pre><span></span><code>ChiselStage.emitSystemVerilog(new Wrapper)
// res2: String = &quot;&quot;&quot;// Generated by CIRCT firtool-1.44.0
// module PipelineStage(    // &lt;stdin&gt;:3:10, :10:10
//   input        io_a_valid,   // connection-operators.md:83:14
//   input  [7:0] io_a_bits,    // connection-operators.md:83:14
//   input        io_b_ready,   // connection-operators.md:83:14
//   output       io_a_ready,   // connection-operators.md:83:14
//                io_b_valid,   // connection-operators.md:83:14
//   output [7:0] io_b_bits // connection-operators.md:83:14
// );
// 
//   assign io_a_ready = io_b_ready;    // &lt;stdin&gt;:3:10, :10:10
//   assign io_b_valid = io_a_valid;    // &lt;stdin&gt;:3:10, :10:10
//   assign io_b_bits = io_a_bits;  // &lt;stdin&gt;:3:10, :10:10
// endmodule
// 
// module Wrapper(  // &lt;stdin&gt;:17:10
//   input        clock,    // &lt;stdin&gt;:18:11
//                reset,    // &lt;stdin&gt;:19:11
//                io_in_valid,  // connection-operators.md:67:14
//   input  [7:0] io_in_bits,   // connection-operators.md:67:14
//   input        io_out_ready, // connection-operators.md:67:14
//   output       io_in_ready,  // connection-operators.md:67:14
//                io_out_valid, // connection-operators.md:67:14
//   output [7:0] io_out_bits   // connection-operators.md:67:14
// );
// 
//   wire       _c_io_a_ready;  // connection-operators.md:72:17
//   wire       _p_io_b_valid;  // connection-operators.md:71:17
//   wire [7:0] _p_io_b_bits;   // connection-operators.md:71:17
//   PipelineStage p (  // connection-operators.md:71:17
//     .io_a_valid (io_in_valid),
//     .io_a_bits  (io_in_bits),
//     .io_b_ready (_c_io_a_ready), // connection-operators.md:72:17
//     .io_a_ready (io_in_ready),
//     .io_b_valid (_p_io_b_valid),
//     .io_b_bits  (_p_io_b_bits)
//   );
//   PipelineStage c (  // connection-operators.md:72:17
//     .io_a_valid (_p_io_b_valid), // connection-operators.md:71:17
//     .io_a_bits  (_p_io_b_bits),  // connection-operators.md:71:17
//     .io_b_ready (io_out_ready),
//     .io_a_ready (_c_io_a_ready),
//     .io_b_valid (io_out_valid),
//     .io_b_bits  (io_out_bits)
//   );
// endmodule
// 
// &quot;&quot;&quot;
</code></pre></div>
<h3 id="_48">结论：<a class="headerlink" href="#_48" title="Permanent link">&para;</a></h3>
<p>Verilog 保持不变，没有产生错误，表明 <code>&lt;&gt;</code> 运算符是可交换的。</p>
<h2 id="2-rhs-lhs-lhs">概念 2：:= 表示分配来自 RHS 的所有 LHS 信号，无论 LHS 上的方向如何。<a class="headerlink" href="#2-rhs-lhs-lhs" title="Permanent link">&para;</a></h2>
<p>使用与上面相同的实验代码，我们设置为测试 <code>:=</code> 的函数。在上面的示例代码中，我们将 <code>&lt;&gt;</code> 的所有实例替换为 <code>:=</code>。（实验的 Scastie 链接：<a href="https://scastie.scala-lang.org/Shorla/o1ShdaY3RWKf0IIFwwQ1UQ/1">https://scastie.scala-lang.org/Shorla/o1ShdaY3RWKf0IIFwwQ1UQ/1</a>）</p>
<div class="highlight"><pre><span></span><code>import chisel3._
import chisel3.util.DecoupledIO
import circt.stage.ChiselStage

class Wrapper extends Module{
  val io = IO(new Bundle {
  val in = Flipped(DecoupledIO(UInt(8.W)))
  val out = DecoupledIO(UInt(8.W))
  })
  val p = Module(new PipelineStage)
  val c = Module(new PipelineStage)
  // connect producer to I/O
  p.io.a := io.in
  // connect producer  to consumer
  c.io.a := p.io.b
  // connect consumer to I/O
  io.out := c.io.b
}
class PipelineStage extends Module{
  val io = IO(new Bundle{
    val a = Flipped(DecoupledIO(UInt(8.W)))
    val b = DecoupledIO(UInt(8.W))
  })
  io.a := io.b
}
</code></pre></div>
<p>下面我们可以看到这个例子的 Verilog 结果：</p>
<div class="highlight"><pre><span></span><code>ChiselStage.emitSystemVerilog(new Wrapper)
// chisel3.package$ChiselException: Connection between sink (PipelineStage.io.a: IO[DecoupledIO]) and source (PipelineStage.io.b: IO[DecoupledIO]) failed @: .bitsio.a.bits in PipelineStage cannot be written from module PipelineStage.
//  at ... ()
//  at repl.MdocSession$MdocApp3$PipelineStage.&lt;init&gt;(connection-operators.md:133)
//  at repl.MdocSession$MdocApp3$Wrapper$$anonfun$30$$anonfun$apply$20.apply(connection-operators.md:117)
//  at repl.MdocSession$MdocApp3$Wrapper$$anonfun$30$$anonfun$apply$20.apply(connection-operators.md:117)
//  at chisel3.Module$.do_apply(Module.scala:54)
//  at repl.MdocSession$MdocApp3$Wrapper$$anonfun$30.apply(connection-operators.md:117)
//  at repl.MdocSession$MdocApp3$Wrapper$$anonfun$30.apply(connection-operators.md:117)
//  at chisel3.internal.plugin.package$.autoNameRecursively(package.scala:33)
//  at repl.MdocSession$MdocApp3$Wrapper.&lt;init&gt;(connection-operators.md:117)
//  at repl.MdocSession$MdocApp3$$anonfun$39$$anonfun$apply$25.apply(connection-operators.md:141)
//  at repl.MdocSession$MdocApp3$$anonfun$39$$anonfun$apply$25.apply(connection-operators.md:141)
//  at ... ()
//  at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace)
</code></pre></div>
<h3 id="_49">结论：<a class="headerlink" href="#_49" title="Permanent link">&para;</a></h3>
<p><code>:=</code> 运算符在 LHS 上逐个字段，并试图将其连接到来自 RHS 的相同命名信号。如果 LHS 上的某个信号实际上是输入，或者 RHS 上的相应信号是输出，则会出现如上所示的错误。</p>
<h2 id="3-dontcare-wires">概念 3：总是使用 := 来把 DontCare 赋值给 Wires<a class="headerlink" href="#3-dontcare-wires" title="Permanent link">&para;</a></h2>
<p>将 <code>DontCare</code> 分配给未定向的对象时，是否应使用 <code>:=</code> 或 <code>&lt;&gt;</code> ？我们将使用以下示例代码找到答案：（实验的 Scastie 链接：<a href="https://scastie.scala-lang.org/Shorla/ZIGsWcylRqKJhZCkKWlSIA/1">https://scastie.scala-lang.org/Shorla/ZIGsWcylRqKJhZCkKWlSIA/1</a>）</p>
<div class="highlight"><pre><span></span><code>import chisel3._
import chisel3.util.DecoupledIO
import circt.stage.ChiselStage

class Wrapper extends Module{
  val io = IO(new Bundle {
  val in = Flipped(DecoupledIO(UInt(8.W)))
  val out = DecoupledIO(UInt(8.W))
  })
  val p = Module(new PipelineStage)
  val c = Module(new PipelineStage)
  //connect Producer to IO
  io.in := DontCare
  p.io.a &lt;&gt; DontCare
  val tmp = Wire(Flipped(DecoupledIO(UInt(8.W))))
  tmp := DontCare
  p.io.a &lt;&gt; io.in
  // connect producer to consumer
  c.io.a &lt;&gt; p.io.b
  //connect consumer to IO
  io.out &lt;&gt; c.io.b
}
class PipelineStage extends Module{
  val io = IO(new Bundle{
    val a = Flipped(DecoupledIO(UInt(8.W)))
    val b = DecoupledIO(UInt(8.W))
  })
  io.b &lt;&gt; io.a
}
</code></pre></div>
<p>下面我们可以看到这个例子的 Verilog 结果：</p>
<div class="highlight"><pre><span></span><code>ChiselStage.emitSystemVerilog(new Wrapper)
// res5: String = &quot;&quot;&quot;// Generated by CIRCT firtool-1.44.0
// module PipelineStage(    // &lt;stdin&gt;:3:10, :10:10
//   input        io_a_valid,   // connection-operators.md:183:14
//   input  [7:0] io_a_bits,    // connection-operators.md:183:14
//   input        io_b_ready,   // connection-operators.md:183:14
//   output       io_a_ready,   // connection-operators.md:183:14
//                io_b_valid,   // connection-operators.md:183:14
//   output [7:0] io_b_bits // connection-operators.md:183:14
// );
// 
//   assign io_a_ready = io_b_ready;    // &lt;stdin&gt;:3:10, :10:10
//   assign io_b_valid = io_a_valid;    // &lt;stdin&gt;:3:10, :10:10
//   assign io_b_bits = io_a_bits;  // &lt;stdin&gt;:3:10, :10:10
// endmodule
// 
// module Wrapper(  // &lt;stdin&gt;:17:10
//   input        clock,    // &lt;stdin&gt;:18:11
//                reset,    // &lt;stdin&gt;:19:11
//                io_in_valid,  // connection-operators.md:163:14
//   input  [7:0] io_in_bits,   // connection-operators.md:163:14
//   input        io_out_ready, // connection-operators.md:163:14
//   output       io_in_ready,  // connection-operators.md:163:14
//                io_out_valid, // connection-operators.md:163:14
//   output [7:0] io_out_bits   // connection-operators.md:163:14
// );
// 
//   wire       _c_io_a_ready;  // connection-operators.md:168:17
//   wire       _p_io_b_valid;  // connection-operators.md:167:17
//   wire [7:0] _p_io_b_bits;   // connection-operators.md:167:17
//   PipelineStage p (  // connection-operators.md:167:17
//     .io_a_valid (io_in_valid),
//     .io_a_bits  (io_in_bits),
//     .io_b_ready (_c_io_a_ready), // connection-operators.md:168:17
//     .io_a_ready (io_in_ready),
//     .io_b_valid (_p_io_b_valid),
//     .io_b_bits  (_p_io_b_bits)
//   );
//   PipelineStage c (  // connection-operators.md:168:17
//     .io_a_valid (_p_io_b_valid), // connection-operators.md:167:17
//     .io_a_bits  (_p_io_b_bits),  // connection-operators.md:167:17
//     .io_b_ready (io_out_ready),
//     .io_a_ready (_c_io_a_ready),
//     .io_b_valid (io_out_valid),
//     .io_b_bits  (io_out_bits)
//   );
// endmodule
// 
// &quot;&quot;&quot;
</code></pre></div>
<h3 id="_50">结论：<a class="headerlink" href="#_50" title="Permanent link">&para;</a></h3>
<p>如果使用 <code>&lt;&gt;</code> 将未处理的连线 <code>tmp</code> 分配给 DontCare，我们将得到一个错误。但是在上面的例子中，我们使用了 <code>:=</code>，并且没有出现错误。但是，当使用 <code>:=</code> 将导线分配给 DontCare 时，不会发生错误。</p>
<p>因此，当把 DontCare 指定给导线时，请始终使用 <code>:=</code>。</p>
<h2 id="4-dontcare-ios">概念4：您可以使用 <code>&lt;&gt;</code> 或 <code>:=</code> 将 <code>DontCare</code> 分配给有向的事物（IOs）<a class="headerlink" href="#4-dontcare-ios" title="Permanent link">&para;</a></h2>
<p>将 <code>DontCare</code> 分配给定向的对象时，应该使用 <code>:=</code> 还是 <code>&lt;&gt;</code> ？我们将使用以下示例代码找到答案：（实验的 Scastie 链接：<a href="https://scastie.scala-lang.org/Shorla/ZIGsWcylRqKJhZCkKWlSIA/1">https://scastie.scala-lang.org/Shorla/ZIGsWcylRqKJhZCkKWlSIA/1</a>）</p>
<div class="highlight"><pre><span></span><code>import chisel3._
import chisel3.util.DecoupledIO
import circt.stage.ChiselStage

class Wrapper extends Module{
  val io = IO(new Bundle {
  val in = Flipped(DecoupledIO(UInt(8.W)))
  val out = DecoupledIO(UInt(8.W))
  })
  val p = Module(new PipelineStage)
  val c = Module(new PipelineStage)
  //connect Producer to IO
  io.in := DontCare
  p.io.a &lt;&gt; DontCare
  val tmp = Wire(Flipped(DecoupledIO(UInt(8.W))))
  tmp := DontCare
  p.io.a &lt;&gt; io.in
  // connect producer to consumer
  c.io.a &lt;&gt; p.io.b
  //connect consumer to IO
  io.out &lt;&gt; c.io.b
}
class PipelineStage extends Module{
  val io = IO(new Bundle{
    val a = Flipped(DecoupledIO(UInt(8.W)))
    val b = DecoupledIO(UInt(8.W))
  })
  io.b &lt;&gt; io.a
}
</code></pre></div>
<p>下面我们可以在此示例中看到生成的 Verilog：</p>
<div class="highlight"><pre><span></span><code>ChiselStage.emitSystemVerilog(new Wrapper)
// res7: String = &quot;&quot;&quot;// Generated by CIRCT firtool-1.44.0
// module PipelineStage(    // &lt;stdin&gt;:3:10, :10:10
//   input        io_a_valid,   // connection-operators.md:233:14
//   input  [7:0] io_a_bits,    // connection-operators.md:233:14
//   input        io_b_ready,   // connection-operators.md:233:14
//   output       io_a_ready,   // connection-operators.md:233:14
//                io_b_valid,   // connection-operators.md:233:14
//   output [7:0] io_b_bits // connection-operators.md:233:14
// );
// 
//   assign io_a_ready = io_b_ready;    // &lt;stdin&gt;:3:10, :10:10
//   assign io_b_valid = io_a_valid;    // &lt;stdin&gt;:3:10, :10:10
//   assign io_b_bits = io_a_bits;  // &lt;stdin&gt;:3:10, :10:10
// endmodule
// 
// module Wrapper(  // &lt;stdin&gt;:17:10
//   input        clock,    // &lt;stdin&gt;:18:11
//                reset,    // &lt;stdin&gt;:19:11
//                io_in_valid,  // connection-operators.md:213:14
//   input  [7:0] io_in_bits,   // connection-operators.md:213:14
//   input        io_out_ready, // connection-operators.md:213:14
//   output       io_in_ready,  // connection-operators.md:213:14
//                io_out_valid, // connection-operators.md:213:14
//   output [7:0] io_out_bits   // connection-operators.md:213:14
// );
// 
//   wire       _c_io_a_ready;  // connection-operators.md:218:17
//   wire       _p_io_b_valid;  // connection-operators.md:217:17
//   wire [7:0] _p_io_b_bits;   // connection-operators.md:217:17
//   PipelineStage p (  // connection-operators.md:217:17
//     .io_a_valid (io_in_valid),
//     .io_a_bits  (io_in_bits),
//     .io_b_ready (_c_io_a_ready), // connection-operators.md:218:17
//     .io_a_ready (io_in_ready),
//     .io_b_valid (_p_io_b_valid),
//     .io_b_bits  (_p_io_b_bits)
//   );
//   PipelineStage c (  // connection-operators.md:218:17
//     .io_a_valid (_p_io_b_valid), // connection-operators.md:217:17
//     .io_a_bits  (_p_io_b_bits),  // connection-operators.md:217:17
//     .io_b_ready (io_out_ready),
//     .io_a_ready (_c_io_a_ready),
//     .io_b_valid (io_out_valid),
//     .io_b_bits  (io_out_bits)
//   );
// endmodule
// 
// &quot;&quot;&quot;
</code></pre></div>
<h3 id="_51">结论：<a class="headerlink" href="#_51" title="Permanent link">&para;</a></h3>
<p><code>&lt;&gt;</code> 和 <code>:=</code> 均可用于分别为 <code>io.in</code> 和 <code>p.io.a</code> 中所示的有向的（IOs）赋值给 DontCare。这基本上是等效的，因为在这种情况下，<code>&lt;&gt;</code> 和 <code>:=</code> 将确定 LHS 的方向。</p>
<h2 id="5-io-io">概念5：<code>&lt;&gt;</code> 在至少一个已知流向（IO 或子模块的 IO）的事物之间起作用。<a class="headerlink" href="#5-io-io" title="Permanent link">&para;</a></h2>
<p>如果至少有一个已知的流向，<code>&lt;&gt;</code> 会怎么做？这将使用下面的实验代码显示：（实验的 Scastie 链接：<a href="https://scastie.scala-lang.org/Shorla/gKx9ReLVTTqDTk9vmw5ozg">https://scastie.scala-lang.org/Shorla/gKx9ReLVTTqDTk9vmw5ozg</a>）</p>
<div class="highlight"><pre><span></span><code>import chisel3._
import chisel3.util.DecoupledIO
import circt.stage.ChiselStage

class Wrapper extends Module{
  val io = IO(new Bundle {
  val in = Flipped(DecoupledIO(UInt(8.W)))
  val out = DecoupledIO(UInt(8.W))
  })
  val p = Module(new PipelineStage)
  val c = Module(new PipelineStage)
  //connect Producer to IO
    // For this experiment, we add a temporary wire and see if it works...
  //p.io.a &lt;&gt; io.in
  val tmp = Wire(DecoupledIO(UInt(8.W)))
  // connect intermediate wire
  tmp &lt;&gt; io.in
  p.io.a &lt;&gt; tmp
  // connect producer to consumer
  c.io.a &lt;&gt; p.io.b
  //connect consumer to IO
  io.out &lt;&gt; c.io.b
}
class PipelineStage extends Module{
  val io = IO(new Bundle{
    val a = Flipped(DecoupledIO(UInt(8.W)))
    val b = DecoupledIO(UInt(8.W))
  })
  io.b &lt;&gt; io.a
}
</code></pre></div>
<p>下面我们可以在此示例中看到生成的 Verilog：</p>
<div class="highlight"><pre><span></span><code>ChiselStage.emitSystemVerilog(new Wrapper)
// res9: String = &quot;&quot;&quot;// Generated by CIRCT firtool-1.44.0
// module PipelineStage(    // &lt;stdin&gt;:3:10, :10:10
//   input        io_a_valid,   // connection-operators.md:284:14
//   input  [7:0] io_a_bits,    // connection-operators.md:284:14
//   input        io_b_ready,   // connection-operators.md:284:14
//   output       io_a_ready,   // connection-operators.md:284:14
//                io_b_valid,   // connection-operators.md:284:14
//   output [7:0] io_b_bits // connection-operators.md:284:14
// );
// 
//   assign io_a_ready = io_b_ready;    // &lt;stdin&gt;:3:10, :10:10
//   assign io_b_valid = io_a_valid;    // &lt;stdin&gt;:3:10, :10:10
//   assign io_b_bits = io_a_bits;  // &lt;stdin&gt;:3:10, :10:10
// endmodule
// 
// module Wrapper(  // &lt;stdin&gt;:17:10
//   input        clock,    // &lt;stdin&gt;:18:11
//                reset,    // &lt;stdin&gt;:19:11
//                io_in_valid,  // connection-operators.md:263:14
//   input  [7:0] io_in_bits,   // connection-operators.md:263:14
//   input        io_out_ready, // connection-operators.md:263:14
//   output       io_in_ready,  // connection-operators.md:263:14
//                io_out_valid, // connection-operators.md:263:14
//   output [7:0] io_out_bits   // connection-operators.md:263:14
// );
// 
//   wire       _c_io_a_ready;  // connection-operators.md:268:17
//   wire       _p_io_b_valid;  // connection-operators.md:267:17
//   wire [7:0] _p_io_b_bits;   // connection-operators.md:267:17
//   PipelineStage p (  // connection-operators.md:267:17
//     .io_a_valid (io_in_valid),
//     .io_a_bits  (io_in_bits),
//     .io_b_ready (_c_io_a_ready), // connection-operators.md:268:17
//     .io_a_ready (io_in_ready),
//     .io_b_valid (_p_io_b_valid),
//     .io_b_bits  (_p_io_b_bits)
//   );
//   PipelineStage c (  // connection-operators.md:268:17
//     .io_a_valid (_p_io_b_valid), // connection-operators.md:267:17
//     .io_a_bits  (_p_io_b_bits),  // connection-operators.md:267:17
//     .io_b_ready (io_out_ready),
//     .io_a_ready (_c_io_a_ready),
//     .io_b_valid (io_out_valid),
//     .io_b_bits  (io_out_bits)
//   );
// endmodule
// 
// &quot;&quot;&quot;
</code></pre></div>
<h3 id="_52">结论：<a class="headerlink" href="#_52" title="Permanent link">&para;</a></h3>
<p>上面的连接顺利进行，没有错误，只要至少有一个方向的东西（IO 或子模块的 IO）来“解决”方向，这将显示 <code>&lt;&gt;</code>。</p>
<h2 id="6">概念6：<code>&lt;&gt;</code> 和 <code>:=</code> 按字段名称连接信号。<a class="headerlink" href="#6" title="Permanent link">&para;</a></h2>
<p>该实验创建了一个 MockDecoupledIO，其名称与 DeCopledIO 具有相同的字段。Chisel 可以将其连接并产生相同的 Verilog，即使 MockDecoupledIO 和 DeCopledIO 是不同的类型。（实验的 Scastie 链接：<a href="https://scastie.scala-lang.org/uf4tqquvqyigzaw705nfiq">https://scastie.scala-lang.org/uf4tqquvqyigzaw705nfiq</a>）</p>
<div class="highlight"><pre><span></span><code>import chisel3._
import chisel3.util.DecoupledIO
import circt.stage.ChiselStage

class MockDecoupledIO extends Bundle {
  val valid = Output(Bool())
  val ready = Input(Bool())
  val bits = Output(UInt(8.W))
}
class Wrapper extends Module{
  val io = IO(new Bundle {
  val in = Flipped(new MockDecoupledIO())
  val out = new MockDecoupledIO()
  })
  val p = Module(new PipelineStage)
  val c = Module(new PipelineStage)
  // connect producer to I/O
  p.io.a &lt;&gt; io.in
  // connect producer  to consumer
  c.io.a &lt;&gt; p.io.b
  // connect consumer to I/O
  io.out &lt;&gt; c.io.b
}
class PipelineStage extends Module{
  val io = IO(new Bundle{
    val a = Flipped(DecoupledIO(UInt(8.W)))
    val b = DecoupledIO(UInt(8.W))
  })
  io.a &lt;&gt; io.b
}
</code></pre></div>
<p>下面我们可以在此示例中看到生成的 Verilog：</p>
<div class="highlight"><pre><span></span><code>ChiselStage.emitSystemVerilog(new Wrapper)
// res11: String = &quot;&quot;&quot;// Generated by CIRCT firtool-1.44.0
// module PipelineStage(    // &lt;stdin&gt;:3:10, :10:10
//   input        io_a_valid,   // connection-operators.md:337:14
//   input  [7:0] io_a_bits,    // connection-operators.md:337:14
//   input        io_b_ready,   // connection-operators.md:337:14
//   output       io_a_ready,   // connection-operators.md:337:14
//                io_b_valid,   // connection-operators.md:337:14
//   output [7:0] io_b_bits // connection-operators.md:337:14
// );
// 
//   assign io_a_ready = io_b_ready;    // &lt;stdin&gt;:3:10, :10:10
//   assign io_b_valid = io_a_valid;    // &lt;stdin&gt;:3:10, :10:10
//   assign io_b_bits = io_a_bits;  // &lt;stdin&gt;:3:10, :10:10
// endmodule
// 
// module Wrapper(  // &lt;stdin&gt;:17:10
//   input        clock,    // &lt;stdin&gt;:18:11
//                reset,    // &lt;stdin&gt;:19:11
//                io_in_valid,  // connection-operators.md:321:14
//   input  [7:0] io_in_bits,   // connection-operators.md:321:14
//   input        io_out_ready, // connection-operators.md:321:14
//   output       io_in_ready,  // connection-operators.md:321:14
//                io_out_valid, // connection-operators.md:321:14
//   output [7:0] io_out_bits   // connection-operators.md:321:14
// );
// 
//   wire       _c_io_a_ready;  // connection-operators.md:326:17
//   wire       _p_io_b_valid;  // connection-operators.md:325:17
//   wire [7:0] _p_io_b_bits;   // connection-operators.md:325:17
//   PipelineStage p (  // connection-operators.md:325:17
//     .io_a_valid (io_in_valid),
//     .io_a_bits  (io_in_bits),
//     .io_b_ready (_c_io_a_ready), // connection-operators.md:326:17
//     .io_a_ready (io_in_ready),
//     .io_b_valid (_p_io_b_valid),
//     .io_b_bits  (_p_io_b_bits)
//   );
//   PipelineStage c (  // connection-operators.md:326:17
//     .io_a_valid (_p_io_b_valid), // connection-operators.md:325:17
//     .io_a_bits  (_p_io_b_bits),  // connection-operators.md:325:17
//     .io_b_ready (io_out_ready),
//     .io_a_ready (_c_io_a_ready),
//     .io_b_valid (io_out_valid),
//     .io_b_bits  (io_out_bits)
//   );
// endmodule
// 
// &quot;&quot;&quot;
</code></pre></div>
<p>这是另一个实验，在其中我们删除了一个 MockDecoupledIO的领域：（实验的 scastie 链接：<a href="https://scastie.scala-lang.org/chtkhkcps9cvjkjjqpdeia">https://scastie.scala-lang.org/chtkhkcps9cvjkjjqpdeia</a>）</p>
<div class="highlight"><pre><span></span><code>import chisel3._
import chisel3.util.DecoupledIO
import circt.stage.ChiselStage

class MockDecoupledIO extends Bundle {
  val valid = Output(Bool())
  val ready = Input(Bool())
  //val bits = Output(UInt(8.W))
}
class Wrapper extends Module{
  val io = IO(new Bundle {
  val in = Flipped(new MockDecoupledIO())
  val out = new MockDecoupledIO()
  })
  val p = Module(new PipelineStage)
  val c = Module(new PipelineStage)
  // connect producer to I/O
  p.io.a &lt;&gt; io.in
  // connect producer  to consumer
  c.io.a &lt;&gt; p.io.b
  // connect consumer to I/O
  io.out &lt;&gt; c.io.b
}
class PipelineStage extends Module{
  val io = IO(new Bundle{
    val a = Flipped(DecoupledIO(UInt(8.W)))
    val b = DecoupledIO(UInt(8.W))
  })
  io.a &lt;&gt; io.b
}
</code></pre></div>
<p>下面我们可以在此示例中看到生成的 Verilog：</p>
<div class="highlight"><pre><span></span><code>ChiselStage.emitSystemVerilog(new Wrapper)
// chisel3.package$ChiselException: Connection between left (PipelineStage.io.a: IO[DecoupledIO]) and source (Wrapper.io.in: IO[MockDecoupledIO]) failed @.bits: Right Record missing field (bits).
//  at ... ()
//  at repl.MdocSession$MdocApp12$Wrapper.&lt;init&gt;(connection-operators.md:381)
//  at repl.MdocSession$MdocApp12$$anonfun$119$$anonfun$apply$79.apply(connection-operators.md:402)
//  at repl.MdocSession$MdocApp12$$anonfun$119$$anonfun$apply$79.apply(connection-operators.md:402)
//  at ... ()
//  at ... (Stack trace trimmed to user code only. Rerun with --full-stacktrace to see the full stack trace)
</code></pre></div>
<p>这个失败是因为缺少一个字段 <code>bits</code>。</p>
<h3 id="_53">结论：<a class="headerlink" href="#_53" title="Permanent link">&para;</a></h3>
<p>对于 <code>:=</code>, Scala 类型不需要匹配，但是 LHS 上的所有信号都必须由 RHS 提供，否则您将获得 Chisel 错误。RHS 上可能还有其他信号，这些信号将被忽略. 对于 <code>&lt;&gt;</code>, Scala 类型不需要匹配，但是所有信号必须在 LHS 和 RHS 之间完全匹配。在这两种情况下，字段的顺序都不重要。</p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2023 - 2023 Wang Xin
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.dfff1995.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.78eede0e.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>